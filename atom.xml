<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Deng</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-17T15:48:07.188Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>邓浩</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于这个博客</title>
    <link href="http://yoursite.com/2020/05/17/%E5%85%B3%E4%BA%8E%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2020/05/17/%E5%85%B3%E4%BA%8E%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-05-17T15:48:29.759Z</published>
    <updated>2020-05-17T15:48:07.188Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="关于这个博客"><a href="#关于这个博客" class="headerlink" title="关于这个博客"></a>关于这个博客</h1><h4 id="做什么用的"><a href="#做什么用的" class="headerlink" title="做什么用的"></a>做什么用的</h4><p>​    搭建此博客，意在记录学习过程，生活点滴</p><h4 id="为什么选择在这样一个没人知晓的地方写这些东西"><a href="#为什么选择在这样一个没人知晓的地方写这些东西" class="headerlink" title="为什么选择在这样一个没人知晓的地方写这些东西"></a>为什么选择在这样一个没人知晓的地方写这些东西</h4><p>​    我觉得结网上说的挺好的，经过了大学的四分三已经快要过去了，我总得需要留下写东西来证明他的存在，无论是对今后工作还是为回顾过去做点准备。<br>​    其实当初这个博客只是一时兴起，想要来记录自己的自学经历，但总感觉这个地方总有点过于繁琐，需要回顾的存在本地会更加方便。但现在来看，有这样一个既能被人看到，又不那么容易被人看到的小小地方，感觉也挺有趣的。<br>​    对于一些想做，但是又没有立即行动的想法，也许会在将来的几小时/几天烟消云散，有这样一个地方，又会有人时时刻刻监督着一样，我觉得挺有必要的。<br>​    同时，我也希望在将来的某一天回顾的时候，一个大三即将踏入社会的我能够提醒一个可能迷失自我的我，不忘初心。</p><h4 id="关于博客内容"><a href="#关于博客内容" class="headerlink" title="关于博客内容"></a>关于博客内容</h4><h5 id="博客结构示意图"><a href="#博客结构示意图" class="headerlink" title="博客结构示意图"></a>博客结构示意图</h5><p>​        截至2020/5/17此博客第一阶段已完成，愿第二阶段能够至少能够持续五年</p><h5 id="各项说明"><a href="#各项说明" class="headerlink" title="各项说明"></a>各项说明</h5><h6 id="关于主页"><a href="#关于主页" class="headerlink" title="关于主页"></a>关于主页</h6><p>​        起提醒功能，由缘由置顶，依次职业规划(工作)，憧憬(生活)</p><h6 id="其他杂页"><a href="#其他杂页" class="headerlink" title="其他杂页"></a>其他杂页</h6><p>​        codeStudy：记录编程历程(现阶段已完结，之后如果需要可能会继续学习)<br>​        mood：记录心情(发泄或一些杂谈)<br>​        myBook：记录看过的书的一些小小心得<br>​        plan：短期规划<br>​        idea：记录一些小想法，行动之前<br>Ps：详细可看前往各页具体描述(各种类置顶处)</p><h4 id="关于博客的更新规划"><a href="#关于博客的更新规划" class="headerlink" title="关于博客的更新规划"></a>关于博客的更新规划</h4><pre><code>待处理，此处采用GitHub上的项目管理功能</code></pre><h4 id="关于博客的分享"><a href="#关于博客的分享" class="headerlink" title="关于博客的分享"></a>关于博客的分享</h4><pre><code>目前处于积累阶段，或许有一天我会分享给愿意看的人</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Content" scheme="http://yoursite.com/tags/Content/"/>
    
  </entry>
  
  <entry>
    <title>spring注解版</title>
    <link href="http://yoursite.com/2020/04/19/spring%E6%B3%A8%E8%A7%A3%E7%89%88/"/>
    <id>http://yoursite.com/2020/04/19/spring%E6%B3%A8%E8%A7%A3%E7%89%88/</id>
    <published>2020-04-19T09:00:54.000Z</published>
    <updated>2020-05-17T15:49:26.412Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Spring-注解版"><a href="#Spring-注解版" class="headerlink" title="Spring 注解版"></a>Spring 注解版</h2><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h4><ol><li><p>表明改类是一个配置类</p><h4 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h4></li><li><p>将类注入容器</p></li><li><p>value:注入容器中bean 的名称</p><h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4></li><li><p>扫描包,只有扫描到了,类才会被注入容器</p></li><li><p>value:扫描的包的全类名</p></li><li><p>includeFilters:包含的过滤器(只包含了扫描包中,包含的类型)</p></li><li><p>excludefilters:排除的过滤器(排除了所扫描包中,排除的类型)</p><ol><li>取值类型是ComponentScan.Filter[]</li><li>Filter是一个注解<br><img src="/2020/04/19/spring%E6%B3%A8%E8%A7%A3%E7%89%88/img/ComponentScan.png" alt="ComponentScan"></li></ol></li><li><p>可以自定义过滤的方式<br><img src="/2020/04/19/spring%E6%B3%A8%E8%A7%A3%E7%89%88/img/Custom.png" alt="Custom"></p><ol start="0"><li>自定义过滤器,必须实现TypeFilter</li><li>MetadataReader,可以获取扫描的各个类的类信息,可以对此进行判断,然后排除或者包括</li><li>返回的true则会返回,进一步执行<h4 id="Scope-value"><a href="#Scope-value" class="headerlink" title="@Scope(value)"></a>@Scope(value)</h4></li></ol></li><li><p>singleton:单例的(默认):IOC容器启动会调用方法创建对象到IOC容器中,以后每次获取就是直接从容器中拿</p></li><li><p>protocol:多例的.IOC容器启动并不会调用方法创建对象放在容器中,每次获取时,才调用方法创建对象</p></li><li><p>request:同一次请求创建一个实例</p></li><li><p>session:同一个session创建一个实例</p><h4 id="Lazy"><a href="#Lazy" class="headerlink" title="@Lazy"></a>@Lazy</h4></li><li><p>获取对象时,才加载</p><h4 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h4></li><li><p>按照条件给IOC容器注册Bean</p></li><li><p>只有一个参数是Condition类型数组</p><ol><li>自定义选择(必须实现Condition接口)<br><img src="/2020/04/19/spring%E6%B3%A8%E8%A7%A3%E7%89%88/img/Conditional.png" alt="Conditional"></li><li>两个参数:<ol><li>ConditionContext<br><img src="/2020/04/19/spring%E6%B3%A8%E8%A7%A3%E7%89%88/img/ConditionContext.png" alt="ConditionContext"><ol><li>存储了一些获取当前上下文的信息..以及包括系统环境信息等</li><li>返回true则返回给conditional注解<h4 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h4></li></ol></li></ol></li></ol></li><li><p>@Import(要导入到容器的组件),id默认是全类名</p></li><li><p>实现ImportSelector接口:返回需要导入的组件的全类名数组<br><img src="/2020/04/19/spring%E6%B3%A8%E8%A7%A3%E7%89%88/img/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%BC%E5%85%A5%E9%80%89%E6%8B%A9%E5%99%A8.png" alt="自定义导入选择器"></p><ol><li>返回的数组,即为导入的Bean</li></ol></li><li><p>重写ImportBeanDefinitionRegistrar接口的方法<br><img src="/2020/04/19/spring%E6%B3%A8%E8%A7%A3%E7%89%88/img/ImportBeanDefinitionRegistrar.png" alt="ImportBeanDefinitionRegistrar"></p><ol><li>AnnotationMetadata 一些当前类上的数据</li><li>BeanDefinitionRegistry 判断等一系列有关容器bean的方法<h5 id="另一种注入bean的方式"><a href="#另一种注入bean的方式" class="headerlink" title="另一种注入bean的方式"></a>另一种注入bean的方式</h5></li></ol></li><li><p>实现FactoryBean<T>接口,返回的类型则是注入的类型<br> <img src="/2020/04/19/spring%E6%B3%A8%E8%A7%A3%E7%89%88/img/FactoryBean.png" alt="FactoryBean"> </T></p></li><li><p>然后再将此类注入容器,则即可将目标类注入容器,获取的是目标类bean,在容器中,若要获取工厂bean,需要使用容器对象.getBeanById(“ &amp; beanFactory”)</p></li></ol><h3 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h3><ol><li>指定初始化和销毁方法<ol><li>通过@Bean指定init-method和destroy-method</li></ol></li><li>通过让bean实现InitializingBean(定义初始化逻辑),DisposableBean(定义销毁逻辑)<br><img src="/2020/04/19/spring%E6%B3%A8%E8%A7%A3%E7%89%88/img/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F1.png" alt="生命周期1"></li><li>可以使用JSR250<br><img src="/2020/04/19/spring%E6%B3%A8%E8%A7%A3%E7%89%88/img/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F2.png" alt="生命周期2"><ol><li>@PostConstruct:在bean创建完成并且属性赋值完成,来执行该方法</li><li>@PreDestroy:在容器销毁bean之前通知我们进行清理工作</li></ol></li><li>BeanPostProcessor [接口],bean的后置处理器<br><img src="/2020/04/19/spring%E6%B3%A8%E8%A7%A3%E7%89%88/img/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F3.png" alt="生命周期3"><ol><li>在bean初始化前后进行一些处理工作</li><li>postProcessBeforeInitialization:初始化之前</li><li>postProcessAfterInitialization:销毁后之后</li><li>注意:此种方式会将容器种的所有bean执行</li></ol></li><li>spring底层对于BeanPostProcessor的使用<h4 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h4></li><li>基本数值</li><li>可以写SqEL:#{}</li><li>可以写${}:取出配置文件种的值(在运行环境变量中的值,在配置类要加载配置文件)<ol><li>配置文件中的值,也可以从容器中获取,ApplicationContext<h4 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h4></li></ol></li><li>引入配置文件<h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4></li><li>自动注入</li><li>默认优先按照类型去容器中找对应的组件</li><li>如果找到多个相同类型的组件,再将属性名称作为组件的id去容器中查找</li><li>@Qualifier(“BeanId”)强制按照组件的id值进行匹配</li><li>required属性:有这样一个bean就装配,没有就不装配<h5 id="作用位置"><a href="#作用位置" class="headerlink" title="作用位置"></a>作用位置</h5></li><li>构造器:只有一个构造器,有参构造器的@Autowired,可以省略,还是会从容器中自动获取</li><li>方法:spring容器创建对象,就会调用方法,完成赋值<ol><li>方法使用的参数,自定义类型的值,从ioc的容器中拿到</li></ol></li><li>参数</li><li>属性<h4 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h4></li><li>需要和@Autowired组合<h4 id="Primary"><a href="#Primary" class="headerlink" title="@Primary"></a>@Primary</h4></li><li>让spring在装配时,默认使用首选的bean</li><li>优先级比@@Qualifier<h4 id="Resource和-Inject-java规范"><a href="#Resource和-Inject-java规范" class="headerlink" title="@Resource和@Inject(java规范)"></a>@Resource和@Inject(java规范)</h4><h5 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h5></li><li>自动注入</li><li>不支持@Primary功能,和@Autowried(required=flase)<h5 id="Inject"><a href="#Inject" class="headerlink" title="@Inject"></a>@Inject</h5></li><li>需要导入javax.inject,的包</li><li>无@Autowried(required=flase)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="codeStudy" scheme="http://yoursite.com/categories/codeStudy/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="hide" scheme="http://yoursite.com/tags/hide/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC</title>
    <link href="http://yoursite.com/2020/04/19/SpringMVC/"/>
    <id>http://yoursite.com/2020/04/19/SpringMVC/</id>
    <published>2020-04-19T08:10:45.000Z</published>
    <updated>2020-05-17T14:44:08.145Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><ol><li>模块化的开发</li><li>组件<ol><li>前端控制器<ol><li>会拦截所有资源,如果配置使用的是/,页面引入的资源也会拦截.所有需要设置不拦截静态资源<ol><li>&lt;mvc:resources location=”资源位置不拦截” mapping=”请求路径下不拦截”&gt;<br>###请求参数绑定</li></ol></li></ol></li><li>表单提交的参数类型都是键值对形式的</li><li>如何绑定:<ol><li>把表单提交的请求参数,作为控制器中方法的参数进行绑定</li><li>要求:提交表单的name和参数的名称相同</li></ol></li><li>类型:<ol><li>JavaBean对象<ol><li>控制器中的参数为javaBean对象.并且生成各个属性的setter方法.<ol><li>注意:<ol><li>如果javaBean对象中含有另一个Javabean,则需要使各个组件的name属性值,等于javabean对象名.属性</li></ol></li></ol></li><li>在页面中,各个组件的name属性值,必须和setter方法名称一致.去掉set大写变小写</li><li>springMVC会自动封装成一个javaBean对象</li></ol></li><li>集合类型 <ol><li>封装到list集合中<ol><li>页面中的组件的属性名为list集合名[0].javabean对象的属性名.list[0].username,list[0].age</li></ol></li><li>封装到map集合中<ol start="2"><li>页面中的组件的属性名为map集合名[‘key名’].javabean对象的属性名.map[‘key名’].username,map[‘key名’].age</li></ol></li></ol></li></ol></li><li>参数绑定中会出现中文乱码的问题(get请求方式不会)<ol><li>可使用requset请求设置编码</li><li>在web.xml中配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li>在页面发送请求提交的数据中,所有的数据均为String字符串类型,但参数绑定时,springMVC自动将类型转换为要封装的数据类型<ol><li>但是,有时候需要自定义类型转换<ol><li>步骤:<ol><li>实现Converter接口,实现该接口.重写转换方    法 ,Converter&lt;S,T&gt;,转换前数据类型S,转换后数据类型</li><li>在配置文件中注册自定义类型转换器</li></ol></li></ol></li></ol></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"ConversionService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"自定义类型转换器的全类名"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​            3. 还需要开启类型转换器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">"ConversionService"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><ol><li><p>返回值String</p><ol><li>视图解析器会把返回的String类型根据视图解析器配置的路径和文件类型找返回值的字符串.文件类型相匹配的文件</li></ol></li><li><p>返回值void</p><ol><li>默认在视图解析器配置下的路径,找当前请求路径名.文件类型的文件,如果无,则404</li><li>如果想跳转到指定页面,只能使用request对象的转发方法</li><li>或这response对象的重定向方法</li></ol></li><li><p>返回值ModelAndView</p><ol><li>创建ModelAndView对象</li><li>ModelAndView对象可以存值到request域中<ol><li>mv.addObject</li></ol></li><li>ModelAndView对象也可以指定跳转的页面<ol><li>mv.setViewName<ol><li>此方法也会调用视图解析器,解析到指定的目录文件下,然后加上文件类型</li></ol></li></ol></li></ol></li><li><p>使用forward和redirect关键字</p><ol><li>在返回值为String类型下<ol><li>此方法不能调用视图解析器,故需要自己写路径/文件名<ol><li>return “forward:/WEB-INF/pages/success.jsp”</li><li>return “redirect:success.jsp”重定向无法请求到WEB-INF目录下</li></ol></li></ol></li></ol></li><li><p>响应Json数据</p><ol><li>如需封装到javabean中,需要json解析器,使用@RequestBody注解.然后springMVC自动将json数据转为javabean对象<br>###常用的注解</li><li>获取request和response对象<ol><li>在控制器方法上,加(HttpServletRequest request,HttpServletresponse response) </li></ol></li><li>@RequestMapping<ol><li>类上:请求的一级目录:模块路径</li><li>方法上:请求的二级目录</li></ol></li><li>@RequestParam<ol><li>把请求中指定名称的参数给控制器中的形参赋值</li><li>value:请求参数中的名称,和name值一样<ol><li>用于指定请求中的参数名.</li><li>使用此注解后,参数绑定时,名称不需要相同,但@RequestParam()中的name或者value属性值必须和,请求中的参数名相同</li></ol></li><li>required:请求参数中是否必须提供此参数,默认值:true.表示必须提供,如果不提供将报错</li></ol></li><li>@RequestBody<ol><li>用于获取请求体内容.直接使用得到的是key=value的结构的数据</li><li>get请求方式不可以.</li><li>属性<ol><li>required:是否必须有请求体,默认值是:true.当值为true时,get方式会报错.如果值为false时,get请求得到的是null</li></ol></li></ol></li><li>@PathVariable<ol><li>拥有绑定url中的占位符的.例如:url中有/user/{id},{id}是占位符</li><li>属性:<ol><li>value:指定url中占位符名称,必须和@RequestMapping中的url的占位符名称一致</li></ol></li><li>Restful风格的URL<ol><li>请求路径一样,可以根据不同的请求方式,去执行后台的不同方法<ol><li>如:同样的请求路径,但是不同的请求是get post put等等,会执行不同的方法</li></ol></li></ol></li></ol></li><li>@RequestHeader<ol><li>用于获取请求消息头</li><li>属性<ol><li>value:提供消息头名称</li><li>required:是否必须有此消息头</li></ol></li></ol></li><li>@CookieValue<ol><li>用于把指定的cookie名称的值传入控制器方法参数<ol><li>属性:<ol><li>value:指定cookie的名称</li><li>required:是否必须有此cookie</li></ol></li></ol></li></ol></li><li>@ModelAttributes    感觉有点用!!!!<ol><li>可以用于修饰方法和参数<ol><li>方法:表示当前方法会在控制器方法执行之前,先执行,它可以修饰没有返回值的方法,也可以修饰有具体返回值的方法</li><li>参数:获取指定的数据给参数赋值</li></ol></li><li>属性:<ol><li>value:用于获取数据的key.key可以是属性名称,也可以是map结构的key</li></ol></li><li>应用场景:<ol><li>当表单提交数据不是完整的实体类数据时,保证没有提交数据的字段使用数据库原来的数据</li><li>例如:我们在编辑一个用户时,用户有一个创建信息的字段,该字段的值不允许被修改,在提交表单数据时肯定没有此字段的内容,一旦更新会把该字段内容置为null,此时就可以使用此注解解决</li></ol></li><li>在方法上<ol><li>例如,页面传过来的数据不完整,如何利用该注解使一个方法在提交的方法之前执行,可以先行查询数据库然后,再返回一个javabean对象,然后请求的方法再接受javabean对象<ol start="5"><li>在参数上</li></ol></li><li>当此注解在方法上,且方法无返回值时,需要将查询的数据封装到javabean中,再将其封装到map集合中去.</li><li>然后在请求执行的方法的参数列表上,加上该注解并提供map集合中封装的javabean对象的key值.然后用该javabean接受</li></ol></li></ol></li><li>@SessionAttribute:只能作用于类上<ol><li>Model类,ModelMap类,SessionStatus<ol><li>Model可以将参数存入到request域中</li><li>ModelMap可以取出存入到Map集合中</li><li>SessionStatus可以设置域中值的状态</li></ol></li><li>用于多次执行控制器方法间的参数共享<ol><li>属性:<ol><li>value:用于指定存入的属性名称</li><li>type:用于指定存入的数据类型</li></ol></li></ol></li></ol></li></ol></li><li><p>HiddentHttpMehtodFilter过滤器</p><ol><li>由于浏览器form表单只支持get和post请求,而DELETE,PUT等不支持.此过滤器可以将浏览器的请求方式改为指定的请求方式,发送给控制器方法,使得表单提交支持,get,post,put,delete请求</li><li>使用步骤:<ol><li>在web.xml中配置该过滤器</li><li>请求方式必须使用post请求</li><li>按照要求提供_method请求参数,该参数的取值就是需要请求的方式<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"_method"</span> <span class="attr">value</span>=<span class="string">"PUT"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3></li></ol></li></ol></li><li><p>执行原理:</p><ol><li>前端页面选择了上传文件提交了一个request请求</li><li>前端控制器servlet接受到文件上传请求,然后将调用文件解析器</li><li>文件解析器解析request请求,返回一个MultipartFile对象</li><li>前端控制器将MultipartFile对象传给请求的控制器对象的方法</li><li>请求的方法接收MultipartFile对象.<ol><li>ps:MultipartFile对象名称,必须和前端的文件上传的组件的name值相同,推荐为upload</li></ol></li></ol></li><li><p>form表单的enctype取值必须是:multipart/form-data</p><ol><li>默认值:application/x-www-form-urlencodied</li></ol></li><li><p>method属性取值必须是Post</p></li><li><p>提供一个文件选择域</p></li><li><p>步骤:</p><ol><li>配置文件解析器对象:<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResovler"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSize"</span> <span class="attr">value</span>=<span class="string">"10*1024*1024"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>参数上配置接收MultipartFile对象</p><ol><li>有方法获取名称.getOriginalFilename()</li><li>上传文件.transferTo(File file)</li></ol></li></ol><h4 id="跨服务器上传"><a href="#跨服务器上传" class="headerlink" title="跨服务器上传"></a>跨服务器上传</h4><ol><li>导入jar,jersey</li><li>创建客户端对象<ol><li>Client client=Client.create();</li></ol></li><li>和图片服务器进行链接<ol><li>path=”存入的服务器的路径”</li><li>WebResource webResource=client.resource(path+filename);</li></ol></li><li>上传文件<ol><li>webResource.put(upload.getBytes());<br>##异常处理</li></ol></li><li>出现异常跳到友好界面</li><li>异常处理器组件</li><li>步骤<ol><li>编写自定义异常类(做提示信息)</li><li>编写异常处理器(跳转到提示页面)    <ol><li>必须实现HandlerExceptionResolver</li><li>重写方法,方法返回ModelAndView类型.可以到错误跳转页面</li></ol></li><li>配置异常处理器<ol><li><bean id="异常处理器id值" class="异常处理器类路径"></bean><br>##拦截器</li></ol></li></ol></li><li>拦截器和过滤器的区别<ol><li>过滤器是servlet规范中的一部分.任何java web都可以使用</li><li>拦截器,是SpringMVC框架的,只有SpringMVC框架才能用</li><li>过滤器在url-pattern中配置了/*才能对所有资源拦截</li><li>拦截器只会拦截访问控制器的方法.静态资源不拦截</li></ol></li><li>步骤<ol><li>编写拦截器类<ol><li>改类必须实现HandlerInterceptor,</li><li>重写方法preHandle,预处理.在controller方法执行之前.返回true代表放行.false不放行</li><li>postHandle,后处理方法.在controller执行之后的执行,在跳转页面之前,若controller中返回了跳转页面,且此也跳转,则不会跳转到controller指定的页面</li><li>afterCompletion.在跳转页面之后执行</li></ol></li><li>配置拦截器<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">//要拦截的方法</span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">//不要拦截的方法</span><br><span class="line">//<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">//配置拦截器对象</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"拦截器类类路径"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Spring整合SpringMVC和Mybatis"><a href="#Spring整合SpringMVC和Mybatis" class="headerlink" title="Spring整合SpringMVC和Mybatis"></a>Spring整合SpringMVC和Mybatis</h3></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="codeStudy" scheme="http://yoursite.com/categories/codeStudy/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="hide" scheme="http://yoursite.com/tags/hide/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringData</title>
    <link href="http://yoursite.com/2020/04/19/SpringData/"/>
    <id>http://yoursite.com/2020/04/19/SpringData/</id>
    <published>2020-04-19T08:10:29.000Z</published>
    <updated>2020-05-17T14:44:00.309Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="SpringData"><a href="#SpringData" class="headerlink" title="SpringData"></a>SpringData</h2><h3 id="ORM-对象关系映射"><a href="#ORM-对象关系映射" class="headerlink" title="ORM(对象关系映射)"></a>ORM(对象关系映射)</h3><ol><li>对象关系映射,将javabean和数据库字段联系起来.以操作javabean的形式,来操作数据库</li><li>与mybatis不同,orm思想是实现实体类和字段的映射,而</li><li>mybatis是实现实体类和sql语句的映射<br>###JPA</li><li>一套实现ORM思想的API</li><li>注解<ol><li>@Table(name)<ol><li>建立和数据库表之间的映射关系</li><li>属性:<ol><li>name:数据库表名</li></ol></li></ol></li><li>@Entity<ol><li>声明是一个实体类</li></ol></li><li>@Id<ol><li>声明是主键</li></ol></li><li>@GeneratedValue<ol><li>配置主键的生成策略</li><li>属性<ol><li>strategy:<ol><li>GeneratedType枚举类型<ol><li>auto:自动根据数据库选择最优生成策略</li><li>TABLE:创建一张表,记录下一个主键的值</li><li>IDENTITY:自增长,数据库需支持</li><li>SEQUENCE:序列,数据库需要支持</li></ol></li></ol></li></ol></li></ol></li><li>@Column<ol><li>对应字段名</li></ol></li></ol></li><li>快速入门<ol><li>创建主配置文件persistence.xml<ol><li>注意:<ol><li>配置文件名必须为persistence.xml</li><li>配置文件的位置必须在MATE-INF目录下</li></ol></li><li>配置持久化单元<ol><li><persistence-unit> 1. 配置实现了JPA规范的实现类:hibernate     1. <provider> 2. 配置数据库的相关信息<properties><property></property></properties></provider></persistence-unit></li></ol></li></ol></li><li>解析配置文件,创建一个实体管理工厂<ol><li>调用persistence类的静态方法createEntityManagertFactory,传入配置文件中的持久化单元的name名</li><li>获取实体管理对象.实体管理工厂对象的createEntityManager方法</li><li>获取事务管理器对象.实体管理对象的getTransaction方法</li><li>开始事务begin方法.</li><li>CRUD操作<ol><li>persist:添加,参数是实体类</li><li>remove:删除,参数是一个实体类</li><li>merge:修改,参数是一个实体类</li><li>find/getReference:查询<ol><li>参数:<ol><li>参数1:实体类的字节码</li><li>参数2:主键值</li></ol></li><li>两个方法的区别:<ol><li>find:立即加载</li><li>getReference:延迟加载<h4 id="JPQL"><a href="#JPQL" class="headerlink" title="JPQL"></a>JPQL</h4></li></ol></li></ol></li></ol></li></ol></li></ol></li><li>与SQL具有相同的关键字</li><li>使用步骤<ol><li>定义语句</li><li>执行操作<ol><li>使用实体管理对象的createQuery方法,返回Query对象</li></ol></li><li>设置参数<ol><li>Query对象的setParameter方法</li></ol></li><li>获取结果<ol><li>getResultList:结果集</li><li>getSingleResult:单一结果</li></ol></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="codeStudy" scheme="http://yoursite.com/categories/codeStudy/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="hide" scheme="http://yoursite.com/tags/hide/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="http://yoursite.com/2020/04/19/Spring/"/>
    <id>http://yoursite.com/2020/04/19/Spring/</id>
    <published>2020-04-19T08:10:19.000Z</published>
    <updated>2020-05-17T14:43:44.127Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="IOC-amp-AOP"><a href="#IOC-amp-AOP" class="headerlink" title="IOC &amp; AOP"></a>IOC &amp; AOP</h2><h3 id="耦合-程序间的依赖关系"><a href="#耦合-程序间的依赖关系" class="headerlink" title="耦合:程序间的依赖关系"></a>耦合:程序间的依赖关系</h3><pre><code>1. 包括:类之间的依赖和方法之间的依赖</code></pre><h3 id="解耦-降低程序间的依赖"><a href="#解耦-降低程序间的依赖" class="headerlink" title="解耦:降低程序间的依赖"></a>解耦:降低程序间的依赖</h3><p>​    1. 应该做到,编译期不依赖(Resource阶段),运行时依赖(Class类对象阶段)</p><h3 id="解耦的思路"><a href="#解耦的思路" class="headerlink" title="解耦的思路"></a>解耦的思路</h3><pre><code>1. 利用反射创建对象,避免使用new(编译期不依赖,运行时依赖)​    2. 通过读取配置文件获取要创建的对象的全类名(更改对象时,方便)</code></pre><h3 id="bean和javabean"><a href="#bean和javabean" class="headerlink" title="bean和javabean"></a>bean和javabean</h3><ol><li><p>bean:可重用组件的含义</p></li><li><p>javabean,用java语言编写的可重用组件</p><h3 id="工厂模式解耦"><a href="#工厂模式解耦" class="headerlink" title="工厂模式解耦"></a>工厂模式解耦</h3></li><li><p>创建Bean对象的工厂</p></li><li><p>帮助我们创建service和dao对象</p><ol><li>如何做<ol><li>需要通过一个配置文件来配置service和dao<ol><li>配置内容:唯一标志=全限定类名(key-value)</li></ol></li><li>读取配置文件中的配置内容,反射创建对象 </li></ol></li><li>可以是xml和properties</li></ol></li><li><p>利用工厂,利用反射创建对象.</p><ol><li>问题:<ol><li>有些对象,可以是单例对象,即只需要创建一次对象,便可反复使用,可提高程序的效率.(单例多例提高程序效率)</li><li>默认情况,每次运行程序都会创建一个对象</li></ol></li><li>解决:<ol><li>为了防止java的垃圾回收机制,实现单例对象,需将bean对象存储在集合中.<h2 id="IOC-inverse-of-control-控制反转"><a href="#IOC-inverse-of-control-控制反转" class="headerlink" title="IOC,inverse of control 控制反转"></a>IOC,inverse of control 控制反转</h2></li></ol></li></ol></li><li><p>由自己本身对bean的控制权,到由工厂类对bean的控制权,即控制反转</p></li><li><p>new–&gt; beanFactory.getbean(“beanName”);</p><h3 id="pring-IOC"><a href="#pring-IOC" class="headerlink" title="pring IOC"></a>pring IOC</h3></li><li><p>核心容器本质:</p><ol><li>Map集合</li></ol></li><li><p>获取核心容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取核心容器对象</span></span><br><span class="line">ApplicationContext ac=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line"><span class="comment">//2.根据id获取bean对象</span></span><br><span class="line">ac.getBean(<span class="string">"beanName"</span>).<span class="keyword">var</span>;</span><br></pre></td></tr></table></figure></li><li><p>ApplicationContext的三个常用实现类:  </p><ol><li>ClassPathXmlApplicationContext,它可以加载类路径下的配置文件,要求配置文件必须在类路径下,不在的话,加载不了</li><li>FileSystemXmlApplicationContext:他可以加载在磁盘任意路径下的配置文件(必须有访问权限)</li><li>AnnototionConfigApplicationContext:用于读取注解创建容器<h4 id="心容器接口两个接口引发的问题"><a href="#心容器接口两个接口引发的问题" class="headerlink" title="心容器接口两个接口引发的问题:"></a>心容器接口两个接口引发的问题:</h4></li></ol></li><li><p>ApplicationContext:  单例适用</p><ol><li>构建核心容器时,创建对象采用的策略时立即加载的方式.也就是说一读取完配置文件马上就创建配置文件中配置的对象</li></ol></li><li><p>BeanFactory:  多例对象适用<br> 1.构建核心容器时,创建对象次啊去的策略时采取延时加载的方式,也就是说,什么时候获取该对象,什么时候才创建</p><h4 id="建bean的三种方式"><a href="#建bean的三种方式" class="headerlink" title="建bean的三种方式:"></a>建bean的三种方式:</h4></li><li><p>使用默认构造函数创建</p><ol><li>在spring的配置文件中使用bean标签,配以id和class属性后,且没有其他属性和标签时,采用的是默认构造函数创建bean对象,此时如果类中没有默认构造函数,则无法创建<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"instanceFactory"</span> <span class="attr">class</span>=<span class="string">"全类名"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>使用普通工厂的方式创建对象(使用某个类的方法创建对象,并存入spring的容器)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"instanceFactory"</span> <span class="attr">class</span>=<span class="string">"全类名"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">factory-bean</span>=<span class="string">"instanceFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getAccountService(创建bean对象的方法)"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用工厂中的静态方法创建对象(使用某个类中的静态方法创建对象,并存入spring容器)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"全类名"</span> <span class="attr">factory-method</span>=<span class="string">"getAccountService(创建bean对象的静态方法)"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="bean的作用范围"><a href="#bean的作用范围" class="headerlink" title="bean的作用范围"></a>bean的作用范围</h4></li><li><p>通过bean标签的scope属性:</p><ol><li>取值:常用的就是单例和多例<pre><code>* 单例:每次使用的都是同一个对象* 多例:每次使用类都会创建一个新的对象</code></pre><ol><li>singleton:单例的(默认)</li><li>prototype:多例</li><li>request:作用域web应用请求范围</li><li>session:作用域web应用的会话范围</li><li>global-session:作用域集群环境的会话范围(全局会话范围),当不是集群环境时,他就是session<ul><li>一个站点,多个服务器,在同一次会话范围内,更改服务器,确保数据不丢失的<h4 id="bean对象的生命周期"><a href="#bean对象的生命周期" class="headerlink" title="bean对象的生命周期"></a>bean对象的生命周期</h4></li></ul></li></ol></li></ol></li><li><p>单例对象</p><ol><li>出生:容器创建时,对象出生</li><li>活着:容器存在,对象存在</li><li>死亡:容器销毁,对象销毁(需手动关闭,如果main函数结束了,仍未手动关闭,则不会执行销毁方法..来不及关闭就没了)</li></ol></li><li><p>多例对象</p><ol><li>出生:使用时</li><li>活着:使用过程中</li><li>死亡:当对象长时间不用,且没有别的对象引用时,由垃圾回收机制回收<h3 id="依赖注入-DI"><a href="#依赖注入-DI" class="headerlink" title="依赖注入 DI"></a>依赖注入 DI</h3></li></ol></li><li><p>根据IOC的思想,具体的类不再拥有对于对象的控制权,将控制权交由IOC容器,则IOC容器需要对bean进行控制,即创建bean对象权力交由IOC容器,则需要依赖注入(xml配置,和注解配置)</p><ol><li>能注入的数据:三类<ol><li>基本类型和String</li><li>其他bean类型(在配置文件中或者注解中配置过的bean)</li><li>复杂类型/集合类型<ol><li>property+…</li></ol></li></ol></li><li>注入的方式:2种<ol><li>xml配置<ol><li>使用构造函数提供<ol><li>使用的标签:constructor-arg</li><li>使用标签出现的位置:bean标签的内部</li><li>属性<ol><li>type:指定要注入的数据的数据类型,该数据类型也是构造函数中某个参数的数据类型</li><li>index:指定要注入的数据在构造函数中指定索引位置.从0开始</li><li>name:用于指定给构造函数中指定名称的参数赋值</li><li>value:注入的参数的值</li><li>ref:用于指定其他的bean类型数据,在IOC容器中配置过的bean</li><li>特点:<ol><li>在获取bean对象时,注入数据是必须操作,否则对象不能成功创建</li></ol></li></ol></li></ol></li><li>使用set方法提供<ol><li>涉及的标签:property</li><li>出现位置:bean标签的内部</li><li>标签的属性<ol><li>name:指定注入时调用的set方法的名称</li><li>value:提供基本类型或String类型数据</li><li>ref:用于指定其他的bean类型数据,在IOC容器中配置过的</li></ol></li><li>特点:<ol><li>创建时无明确限制,可以直接使用默认构造函数</li></ol></li></ol></li><li>创建对象:<ol><li>bean标签</li></ol></li><li>注入数据<ol><li>property标签</li></ol></li><li>改变作用范围<ol><li>scope属性</li></ol></li><li>生命周期<ol><li>init-method和destory-method属性</li></ol></li></ol></li><li>使用注解提供<ol start="0"><li>需要告知spring在创建容器时要扫描的包,扫描注解<ol><li>context标签<ol><li>context:component-scan base-package=”全类名” </li></ol></li></ol></li><li>创建对象:<ol><li>@Component:把当前对象注入spring容器<ol><li>属性:value:用于指定bean的id,不写名,且首字母该小写</li></ol></li></ol></li><li>注入数据<ol><li>@Autowired:只能注入其他bean<ol><li>作用:自动按照类型注入.只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配.就可以注入成功</li><li>出现位置:可以是变量上,也可以是方法上</li><li>注入类中需要使用的对象</li></ol><ul><li>如果IOC容器中需要注入对象的类型有多个实例匹配的话,会比较对象名称,一致则注入,不一致则报错</li><li>如果只有一个匹配的对象,则无需名称一致</li></ul></li><li>@Qualifier:只能注入其他bean<ol><li>作用:在按照类中注入的基础之上再按照名称注入,他再给类成员注入时不能单独使用,但是在给方法参数注入时可以</li><li>属性:<ol><li>value:用于指定注入bean的ID</li></ol></li></ol></li><li>@Resource:只能注入其他bean<ol><li>作用:直接按照bean的id注入.可以单独使用</li><li>属性:<ol><li>name:用于指定bean的id</li></ol></li></ol></li><li>@Value<ol><li>作用:用于注入基本类型和String类型的数据</li><li>属性:<ol><li>value:用于指定数据的值,他可以使用Spring中的spel(spring中的el表达式)</li><li>spel写法:${表达式}</li></ol></li></ol></li></ol></li><li>改变作用范围<ol><li>Scope<ol><li>作用<ol><li>指定bean的作用范围</li></ol></li><li>属性:<ol><li>value:指定范围的取值.常用取值:singleton\prototype</li></ol></li></ol><ul><li>注意.多例对象的销毁由java垃圾回收机制处理</li></ul></li></ol></li><li>生命周期<ol><li>init-method和destory-method属性</li><li>@PreDestory(销毁)\PostConstruct(初始化)</li></ol></li></ol></li></ol><ul><li>三个注解:作用和Component一致,只有一些细微的差别<ul><li>Controller:一般用在表现层</li><li>Service:业务层</li><li>Repository:持久层<h3 id="全注解开发"><a href="#全注解开发" class="headerlink" title="全注解开发"></a>全注解开发</h3></li></ul></li></ul></li></ol></li></ol><ul><li>由于之前的注解不能完全解决我们的需求,还需要通过xml的形式解决一些包的扫描,以及驱动的注册..</li></ul><ol><li>创建一个配置类:<ol><li>@Configuration(标明该类是一个配置类)<ol><li>细节<ol><li>当配置类作为AnnototionConfigApplicationContext创建的参数时.该注解可以不写</li></ol></li></ol></li><li>@ComponentScan(通过注解,指定要扫描的包)<ol><li>属性:<ol><li>value:指定basepackage,即要扫描的包</li><li>basepackage:指定要扫描的包<ul><li>都是数组,用大括号括起来,两个作用一样</li></ul></li></ol></li></ol></li><li>@Bean(用于把当前方法的返回值作为bean对象存入spring容器中)<ol><li>属性:<ol><li>name:用于指定bean的id.默认值是:当前方法名</li></ol></li><li>细节:<ol><li>当使用注解配置方法时,如果方法有参数,spring框架会去容器中查找是否有可用的bean对象…方式和@Autowired一样</li></ol></li></ol></li><li>@Import(导入其他的配置类)<ol><li>value:用于指定其他配置类的字节码<ol><li>当我们使用import注解之后,有import注解的类就是主配置类,导入的都是子配置类</li></ol></li></ol></li><li>@PropertySource(classpath:导入配置文件路径)<ol><li>作用:定义配置类的时候,例如像JDBC的驱动注册,需要一些配置参数,则需要用到配置文件</li></ol></li></ol></li><li>AnnototionConfigApplicationContext:用于读取注解创建容器<ol><li>用此构造方法导入配置类AnnototionConfigApplicationContext(“测试类名” </li></ol><ul><li>用此方法导入的配置类上不需要写@Configuration表面这是配置类,此构造方法,可以传入多个配置类参数,都是字节码类<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4></li></ul></li><li>在使用junit单元测试的时候,使用了大量的创建spring容器,获取bean的代码</li><li>解决:<ol><li>导入spring整合的junit的jar(坐标Spring-test)</li><li>使用Junit提供的一个注解把原有的main方法替换,替换成spring提供的<ol><li>@Runwith(SpringJunit4ClassRunner.class)</li></ol></li><li>告知spring的运行器,spring和ioc创建是基于xml的还是注解的,并说明位置<ol><li>@ContextConfiguration<ol><li>Loactions:指定xml文件的位置,加上classpath:指明在类路径下</li><li>class:指定注解类的所在滴</li></ol></li></ol></li></ol><ul><li>当我们使用spring5版本的时候,junit的jar包必须是4.12及以上<h4 id="junit运行时的原理"><a href="#junit运行时的原理" class="headerlink" title="junit运行时的原理:"></a>junit运行时的原理:</h4></li></ul></li><li>Junit单元测试中,没有main方法也可以执行<ol><li>junit集成了一个main方法</li><li>该方法就会判断当前测试类那些方法有@Test注解</li><li>Junit就会让含有@Test注解的方法执行</li></ol></li><li>在执行单元测试的时候,Junit不知道我们使用的是Spring框架,也就不会读取配置文件,也不会帮我们创建核心容器</li><li>所以,需要将spring和junit整合<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2></li><li>特点:字节码随用随创建,随用随加载</li><li>作用:不修改源码的基础上对方法增强<h3 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h3></li></ol><ul><li>设计的类:Proxy</li><li>提供者:JDK官方<ol><li>如何创建代理对象:<ol><li>使用Proxy类中的newProxyInstance方法</li></ol></li><li>创建代理对象的要求:<ol><li>被代理类最少实现一个接口,如果没有则不能使用</li></ol></li><li>newProxyInstance方法的参数:<ol><li>ClassLoader:类加载器<ol><li>用于今安在代理对象字节码的.和被代理对象使用相同的类加载器,固定写法</li></ol></li><li>Class[]:字节码数组<ol><li>用于让代理对象和被代理对象有相同的方法,固定写法</li></ol></li><li>InvocationHandler:用于提供增强的代码<ol><li>他是让我们写如何代理,我们一般都是写一个该接口的实现类,通常情况下都是匿名内部类,但不必须<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">IProducer proxyProducer=(IProducer)Proxy.newProxyInstance(Producer.getClass().getClassLoader(),Producer.getClass().getInterfaces(),<span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*作用:执行被代理对象的任何接口方法都会经过该方法</span></span><br><span class="line"><span class="comment">*方法参数的含义</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> proxy 代理对象的引用</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> method 当前执行的方法</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> args 当前方法执行所需的参数</span></span><br><span class="line"><span class="comment">*<span class="doctag">@return</span> 和被代理对象方法有相同的返回值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy,Method method,Object[] args)</span><span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line"><span class="comment">//增强的方法体</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol></li><li>注意匿名内部类,访问外部成员时,外部成员必须是最终的<h3 id="基于子类的动态代理"><a href="#基于子类的动态代理" class="headerlink" title="基于子类的动态代理"></a>基于子类的动态代理</h3></li><li>需要外部的jar包,cglib 2.1_3</li><li>设计的类:Enhancer</li><li>提供者:第三方cglib库<ol><li>如何创建代理对象:<ol><li>使用Enhancer类中的create方法</li></ol></li><li>创建代理对象的要求:<ol><li>被代理类不能是最终类</li></ol></li><li>newProxyInstance方法的参数:<ol><li>Class:字节码<ol><li>用于指定被代理对象的字节码.</li></ol></li><li>Callback:用于提供增强的代码<ol><li>他是让我们写如何代理,我们一般都是写一个该接口的实现类,通常情况下都是匿名内部类,但不必须.</li><li>此接口是谁用谁写</li><li>我们一般写的的是该接口的子接口实现类:MethodInterceptor<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//他是让我们写如何代理</span></span><br><span class="line">Enhancer.create(producer.getClass(),<span class="keyword">new</span> MethodInterceptor()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*作用:执行被代理对象的任何接口方法都会经过该方法</span></span><br><span class="line"><span class="comment">*方法参数的含义</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> proxy 代理对象的引用</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> method 当前执行的方法</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> args 当前方法执行所需的参数</span></span><br><span class="line"><span class="comment">//以上三个和基于接口的参数一致</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> methodProxy:当前执行方法的代理对象</span></span><br><span class="line"><span class="comment">*<span class="doctag">@return</span> 和被代理对象方法有相同的返回值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy,Method method,Object[] args,MethodProxy methodProxy)</span><span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line"><span class="comment">//增强的方法体</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="AOP-aspect-of-Programe面向切面变成-增强方法"><a href="#AOP-aspect-of-Programe面向切面变成-增强方法" class="headerlink" title="AOP aspect of Programe面向切面变成(增强方法)"></a>AOP aspect of Programe面向切面变成(增强方法)</h2></li></ol></li></ol></li></ol></li></ul><ol><li>连接点:Joinpoint<ol><li>被代理类的所有方法..被代理类的所有方法都会被拦截,即每个链接点都会被拦截</li></ol></li><li>切入点:Pointcut<ol><li>被代理类的方法中的被增强的方法</li></ol></li><li>通知/增强:Advice<ol><li>拦截到连接点之后要做的事情就是通知(增强的方法体)</li><li>通知类型:<ol><li>前置通知:在执行invoke方法之前的</li><li>后置通知:在执行invoke方法之后的</li><li>异常通知:在catch中的</li><li>最终通知:在finally中的</li><li>环绕通知:整个增强的invoke方法体</li></ol></li></ol></li><li>引介:Introduction</li><li>目标对象:Target<ol><li>被代理对象</li></ol></li><li>织入:Weaving<ol><li>增强被代理对象的过程,也就是增强方法的体现</li></ol></li><li>代理:Proxy<ol><li>代理对象</li></ol></li><li>切面:Aspect<ol><li>切入点和通知的集合<ol><li>建立切入点方法和通知方法的联系<br>####基于XML配置文件的配置代理方式</li></ol></li></ol></li><li>把通知Bean交给spring来管理</li><li>使用aop:config标签表明开始AOP的配置</li><li>使用aop:aspect标签表明配置切面<ol><li>id属性:是给切面提供一个唯一标识</li><li>ref属性:是指定通知类的bean的id</li></ol></li><li>在aop:aspect标签的内部使用对应的标签来配置通知的类型<ol><li>aop:before:表示配置前置通知<ol><li>method属性:用于指定Logger类中那个方法是前置通知</li><li>pointcut属性:用于指定切入点表达式,该表达式的含义指的是对业务层哪些方法进行增强<ol><li>切入点表达式的写法:  需要解析器:aspectjweaver <ol><li>关键字:execution(表达式)</li><li>表达式:<ol><li>访问修饰符(可省) 返回值 包名.类名.方法名(参数表)<ol><li>返回值可以用 *代替,表示任意返回值</li><li>包名可以使用 *代替,表示任意包,有几个包就写几个</li><li>包名可以使用 ..表示当前包及其子包</li><li>类名和方法名可以使用*来通配</li><li>参数列表:<ol><li>可以直接写数据类型:<ol><li>基本类型直接写名称</li><li>引用类型写包名.类名</li></ol></li><li>可以使用*表示任意类型,无参不可以</li><li>可以使用..表示有无参数均可</li></ol></li></ol></li></ol></li><li>全通配写法:<ul><li><b>*&nbsp;&nbsp;&nbsp;<em>..</em>.*(..)</b></li></ul></li><li>实际开发一般写法<ul><li><b>*&nbsp;&nbsp;&nbsp;包名.类名.*(..)</b></li></ul></li></ol></li></ol></li><li>pointcut-ref:引入一个切入点表达式</li></ol></li><li>四种常用的通知<ol><li>aop:before</li><li>aop:after-returing</li><li>aop:after-throwing</li><li>aop:after</li></ol></li><li>切入点表达式标签<ol><li>aop:pointcut<ol><li>属性:<ol><li>id:唯一标识符</li><li>expression:表达式</li></ol></li></ol></li><li>此标签写在aop:aspect标签内部只能当前切面使用</li><li>还可以卸载aop:aspect外面,此时就变成了所有切面可用</li><li>aop约束规定,poincut标签,必须在切面标签之前</li></ol></li><li>环绕通知<ol><li>aop:around</li><li>问题:<ol><li>当我们配置了环绕通知后,切入点方法没有执行,而通知方法执行了</li></ol></li><li>分析:<ol><li>通过对比动态代理的环绕通知代码,发现了动态代理的环绕通知有明确的切入点方法调用,而环绕通知中没有</li></ol></li><li>解决:<ol><li>spring框架提供了一个接口:ProceedingJoinPoint.该接口有一个方法proceed(),此方法就相当于明确的调用了切入点方法.该接口可以作为环绕通知的方法参数,在执行程序时,spring会为我们提供该接口的实现类供我们使用</li></ol></li><li>好处:<ol><li>可以在代码中手动增强方法何使执行的方式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint pjp)</span></span>&#123;</span><br><span class="line">pjp.proceed(pjp.getArgs());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol></li></ol><ul><li>注意:基于接口的动态代理,在获取bean的时候,只能用接口类实现<h3 id="基于注解的代理方式"><a href="#基于注解的代理方式" class="headerlink" title="基于注解的代理方式"></a>基于注解的代理方式</h3></li></ul><ol><li>注解配置,必须声明扫描的包</li><li>必须配置spring开启注解AOP的支持<ol><li>xml形式<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>@EnableAspectJAutoProxy</li></ol></li><li>@Aspect<ol><li>表示当前类是一个切面类:相当于aop:aspect</li></ol></li><li>@Before(“pt1()”)</li><li>@After(“pt1()”)</li><li>@After-returning(“pt1()”)</li><li>@After-thorwing(“pt1()”)</li><li>@Arround(“pt1()”)</li><li>@Pointcut<ol><li>形式:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* 包名.类名.*(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pt1</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h6 id="注意-spring基于注解的非环绕通知的调用顺序最终通知的顺序在后置通知和错误通知之前-环绕通知顺序正常"><a href="#注意-spring基于注解的非环绕通知的调用顺序最终通知的顺序在后置通知和错误通知之前-环绕通知顺序正常" class="headerlink" title="注意:spring基于注解的非环绕通知的调用顺序最终通知的顺序在后置通知和错误通知之前,环绕通知顺序正常"></a>注意:spring基于注解的非环绕通知的调用顺序最终通知的顺序在后置通知和错误通知之前,环绕通知顺序正常</h6><h2 id="JDBCTemplate"><a href="#JDBCTemplate" class="headerlink" title="JDBCTemplate"></a>JDBCTemplate</h2><ol><li>基于xml<ol><li>配置JDBCTemplate,引入dataSource<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/springtest"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"19723dd"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>获取容器</li><li>获取对象</li><li>执行操作<ol><li>query方法,的RowMapper是将结果集存储到list集合中,可用实现类BeanPropertyRowMapper,也可以实现该接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line"><span class="comment">//        JdbcTemplate jdbcTemplate = applicationContext.getBean("jdbcTemplate",JdbcTemplate.class);</span></span><br><span class="line"><span class="comment">//        jdbcTemplate.execute("select * from account");</span></span><br><span class="line"><span class="comment">//        List&lt;Account&gt; query = jdbcTemplate.query("select * from account", new BeanPropertyRowMapper&lt;Account&gt;(Account.class));</span></span><br><span class="line"><span class="comment">//        List&lt;Account&gt; query1 = jdbcTemplate.query("select * from account", new RowMapper&lt;Account&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            public Account mapRow(ResultSet resultSet, int i) throws SQLException &#123;</span></span><br><span class="line"><span class="comment">//                Account account = new Account();</span></span><br><span class="line"><span class="comment">//                account.setId(resultSet.getInt(1));</span></span><br><span class="line"><span class="comment">//                account.setMoney(resultSet.getDouble(2));</span></span><br><span class="line"><span class="comment">//                return account;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li>Spring提供了一个jdbcDaoSupport父类,继承可以减少子类中定义的jdbcTemplate重复的代码.底层源码提供了setdatasource,如果无jdbcTemplate,可以自动帮我们创建一个jdbcTemplate<br>##事务控制</li><li>基于xml<ol start="0"><li>导入xlmns:tx约束,也需要aop的约束</li><li>配置事务管理器</li><li>配置通知<ol><li><a href="tx:advice">tx:advice</a>标签<ol><li>属性:<ol><li>id:给事务唯一标识</li><li>transaction-manager:给事务通知提供一个事务管理器</li></ol></li><li><a href="tx:attributes">tx:attributes</a>标签,给方法添加事务通知<ol><li>方法可以用通配符:*标识.find*标识find开头的所有方法.标识范围越大,优先级越低</li></ol></li></ol></li></ol></li><li>配置切面<ol><li>配置切入点表达式</li><li>配置切入点:通知<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSourceTransactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"ds"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"tx-manager"</span>  <span class="attr">transaction-manager</span>=<span class="string">"dataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"findAll"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">//      isolation:用于指定事物的隔离级别.默认值是DEFAULT,表示使用的是数据库的默认隔离级别</span><br><span class="line">//        no-rollback-for:用于指定一个异常,当产生该异常时,事物不回滚,产生其他异常时,事物回滚.没默认值,表示任何异常都回滚</span><br><span class="line">//        propagation:用于指定事物的传播行为,默认值是REQUIRED,表示一定会有事物,增删改的选择.盖勋方法可以选择SUPPORTS</span><br><span class="line">//        read-only:用于指定事物是否可读.只有查询方法才能设置为ture,默认值false,表示读写</span><br><span class="line">//        rollback-for:用于指定一个异常,当产生该异常时,事物回滚,产生其他异常时,事物不回滚.没默认值,表示任何异常都回滚</span><br><span class="line">//        timeout:用于指定事物的超时时间,默认值时-1,表示永不超时,如果指定了数值,则以秒为单位</span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt1"</span> <span class="attr">expression</span>=<span class="string">"execution(* service.service.*(..))"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"tx-manager"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li>基于注解<ol><li>配置事务管理器</li><li>开启对注解事务的支持<ol><li>@EnalbeTransactionManagement</li></ol></li><li>@Transactional注解<ol><li>表示该处利用了事务管理器,属性和上面相同</li><li>注解不可被继承,不要再接口上定义.只能再public上</li></ol></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="codeStudy" scheme="http://yoursite.com/categories/codeStudy/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="hide" scheme="http://yoursite.com/tags/hide/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>mybatis</title>
    <link href="http://yoursite.com/2020/04/19/mybatis/"/>
    <id>http://yoursite.com/2020/04/19/mybatis/</id>
    <published>2020-04-19T08:10:08.000Z</published>
    <updated>2020-05-17T14:43:38.089Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h2><h3 id="OGNL表达式"><a href="#OGNL表达式" class="headerlink" title="OGNL表达式"></a>OGNL表达式</h3><ol><li>通过对象的取值方法来获取数据</li><li>见机行事</li></ol><h3 id="mybatis的环境搭建"><a href="#mybatis的环境搭建" class="headerlink" title="mybatis的环境搭建"></a>mybatis的环境搭建</h3><ol><li>创建maven工厂并导入坐标</li><li>创建实体类和dao接口</li><li>创建Mybatis的主配置文件<ol><li>sqlMapConfig.xml<ol><li>引入约束</li><li>标签<configuration>下配置<ol><li><properties>标签优先于任何标签,用于加载其他配置文件,一般引入mysql配置文件<ol><li>resource属性</li><li>url属性:必须按照url写法来写地址<ol><li>协议 主机 端口 URI</li><li>URI:</li></ol></li></ol></properties></li><li><environments>标签配置环境,配置事务管理器和datasource对象 多个<environment>标签中,必须至少有一个标签id和<environments>标签id一致<ol><li><transactionManager>事务管理器标签.<ol><li>type属性取值:<ol><li>JDBC,使用JDBC的回滚和</li><li>提交</li><li>MANAGED ,从不回滚和提交</li><li>如果使用spring中的自定义的事务类来覆盖取值</li></ol></li></ol></transactionManager></li><li><dataSource> 1. type属性取值:     1. UNPOOLED,实现了UnpooledDataSource         1. 非池,没用数据库连接池,每次发送sql请求时,都会开启链接,完成了会关闭链接...效率较低     2. POOLED,实现了PooledDataSource         1. 反             1. mybatis提供的池,是线程安全的,队列结构         2. 使用细节:             1. 内部有活动池,和空闲池两个池                 1. 如果空闲池中有空闲状态的,直接使用                 2. 如果空闲池中无空闲状态的链接,再检查活动池,活动池如果链接数小于最大链接数,则创建一个链接对象                 3. 如果空闲池中无空闲状态的链接,且活动池的已到达最大链接数,则会取出活动池的链接时间最久的链接对象,也就是队列为0的连接对象,将其移除,并创建新的连接对象     3. JNDI:使用服务器提供的JNDI技术实现,来获取DataSource对象,不同服务器拿到的DataSource不一样.只能在web或maven中的war工程中使用.         1. tomcat服务器采用的是dbcp链接池         2. 根据服务器的不同,连接池技术也不同..         3. 使用JNDI在不同服务器下,需要配置DataSource属性,在tomact服务器下需要在webapp目录下创建META-INF目录下的配置文件进行相关配置(文件夹不能改变)         4. 配置文件的位置在<b>java:comp/env/jdbc/文件名</b>.固定不变         4. 模仿Windows注册表,采用键值对的形式,记录值,在tomcat服务器中,目录结构可以自己定义,也就是键名,</dataSource></li></ol></environments></environment></environments></li><li><mappers>标签,用于引入配置文件<ol><li><mapper> 1. resource属性:用于指定每个接口映射的配置文件的为止 2. url属性:必须按照url写法来写地址 3. class属性:使用注解时,写该接口全类名则可以实现映射.     1. 注意:<b>如果既有注解又有同级目录下的接口映射配置文件,则会报错,所以,当有注解开发时,都使用<package>标签</package></b></mapper></li><li><package>,用于指定dao接口所在的包,当指定完成后,改包下的映射配置文件,自动导入<ol><li>name属性</li></ol></package></li></ol></mappers></li><li><typeAliases>标签,配置别名,只能配置domainl类中的别名<ol><li><typeAlias>配置别名<ol><li>type属性:指定实体类的全类名,</li><li>alias属性:指定属性的别名,指定了之后,别名不分大小写</li></ol></typeAlias></li><li><package>标签,指定配置别名的包,指定了之后,该包下的实体类都会注册一个别名,并且类名就是别名,不区分大小写<ol><li>name属性</li></ol></package></li></ol></typeAliases></li></ol></configuration></li></ol></li></ol></li><li>创建映射配置文件<ol><li>IUserDao.xml </li><li>每个dao的独立配置文件<ol><li>引入约束</li><li>标签<mapper>配置每个接口的映射配置文件<ol><li>有namespace属性,用来精准定位接口中的抽象方法…如果不加,且多个接口中含有相同方法名称则会报错</li></ol></mapper></li><li>再引入各种CRUD标签<ol><li>含有返回值的方法,需要明确定义返回值类型,标签属性resultType</li><li>含参方法,需要明确定义参数类型parameterType</li><li>可以使用#{}占位符,如果参数是对象类型,可以使用对象.属性名赋值,但如果标签中写了参数类型则只需要,写属性名,也就是该属性的setter方法,去掉set首字母变小写即可如….</li></ol></li></ol></li></ol></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"insert"</span> <span class="attr">parameterType</span>=<span class="string">"service.Account"</span>&gt;</span></span><br><span class="line">    insert into account(id,money)values(#&#123;id&#125;,#&#123;money&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>注意事项:<ol><li>创建IUserDao.xml和IUserDao.java时,名称一致,但是我们一般把接口的配置文件叫IUserMapper,但是意义一样.</li><li>在idea中创建目录的时候,他和包是不一样的<ol><li>包可以用点表示级别</li><li>目录不能,只能一级一级创建</li></ol></li><li>mybatis的映射文件配置必须和dao接口的包结构一致</li><li>映射配置文件的操作配置(select),id属性值必须和dao接口中的方法名相同.且必须配置resultType返回值类型,传输全类名</li></ol></li></ol><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><ol><li><p>读取配置文件</p><ol><li>InputStream in=Resources.getResourceAsStream(“主配置文件名”);</li></ol></li><li><p>创建SqlSessionFactory工厂</p><ol><li>SqlSessionFactoryBuilder builder=new SqlSessionFactoryBuild();</li><li>SqlSessionFactory factory=builder.build(in);<ol><li>读取配置文件流对象</li></ol></li></ol></li><li><p>使用工厂生产SqlSession对象</p><ol><li>SqlSession session=factory.openSession();</li></ol></li><li><p>使用SqlSession创建Dao接口的代理对象</p><ol><li>IuserDao userDao=session.getMapper(IUserDao.class)</li></ol></li><li><p>使用代理对象执行方法</p><ol><li>UserDao.findAll();</li></ol></li><li><p>释放资源  </p><ol><li>session.close();</li><li>in.close();</li></ol></li><li><p>不要忘记在映射接口的配置文件中,定义数据封装的类型</p></li><li><p><b>使用的设计模式</b></p><ol><li>工厂模式<ol><li>使用工厂模式,降低耦合,直接调用方法拿到对象</li></ol></li><li>构建者模式<ol><li>使用sqlSeessionFactoryBuild.build创建了sqlSessionFactory工厂.传入了配置文件字节流..</li><li>该设计模式,隐藏了创建众多诸如与datasource,statement对象的细节,更简化开发</li></ol></li><li>代理模式:<ol><li>对方法增强而不修改源码<br>#####动态SQL</li></ol></li></ol></li><li><p>如果需要根据某个值来查询,某些数据,但不确定这个值是实体类对象中的哪个属性,如何做</p><ol><li>可以使用<if>标签<ol><li><if> 1. test属性:判断的表达式</if></li></ol></if></li><li>注意,查询语句后需要恒为真如<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select * from user where 1=1</span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username!=null"</span>&gt;</span></span><br><span class="line">and username=#&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"age!=null"</span>&gt;</span></span><br><span class="line">age=#&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>不要忘记写,参数类型,因为使用了OGNL表达式</p></li><li><p>上例子的另一种写法,更方便</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select * from user</span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username!=null"</span>&gt;</span></span><br><span class="line">and username=#&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"age!=null"</span>&gt;</span></span><br><span class="line">age=#&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>SQL IN,select * from user where id in(1,2,3)</p><ol><li>可以使用<foreach>标签<ol><li>collection属性:集合(在实体类中想要传入参数的集合)</li><li>open属性:开始的部分,也就是sql语句:(select * from user)后面部分的拼接<ol><li>and in id(</li></ol></li><li>close属性:结束的部分,也就是紧接着open的后面,一般为)</li><li>item属性:遍历出来的结果存入的变量,OGNL表达式取值名,为item属性值</li><li>separator属性:集合用什么分割,一般是,<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select * from user</span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"ids(集合名)!=null"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"ids(集合名)"</span> <span class="attr">open</span>=<span class="string">"and in id ("</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">item</span>=<span class="string">"id"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line"> #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3></li></ol></foreach></li></ol></li><li><p>like #{name} 常用 使用占位符的方式,</p><ol><li>调用方法时,传参加%,如findByName(“%王%”)</li></ol></li><li><p>like ‘%${name}%’    字符串拼接,不常用</p><ol><li>调用时,直接传name值</li></ol></li><li><p>因为两个对象不同,占位符使用的是preperedStatement,字符串拼接的是Statement.</p><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3></li><li><p>如何获取自增长字段的ID值</p><ol><li>使用select last_insert_id()</li><li>在配置文件中<insert>标签的内部加上<selectKey><ol start="3"><li><selectKey>       1. keyProperty属性:属性名                2. keyColumn属性:数据库字段名       3. resultType属性:返回值类型                  4. order属性:枚举值.有AFTER,BEFORE两个取值,是在执行语句前执行还是在执行语句后执行</selectKey></li></ol></selectKey></insert></li></ol></li><li><p>如何将不相同的数据库列名和实体类属性名对应起来</p><ol><li>使用resultMap标签<ol><li>id标签(主键)<pre><code>1. property属性:         3. 实体类的属性名2. column属性:数据库列名</code></pre></li><li>reslut标签(非主键)<pre><code>1. property属性:实体类的属性名         2. column属性:数据库列名</code></pre></li><li>association标签,用于配置封装一个对象,一对一的关系映射,也使用id和result标签配置成员属性<pre><code>1. javaType属性:用于提示封装到那个对象</code></pre></li><li>collection标签:用于封装一个集合对象.一对多的关系映射也使用id和result标签配置成员属性<pre><code>1. 属性:             1. property属性:成员属性名            2. column属性:用那个字段查询的                                        3. oftype属性:用于封装到那个对象</code></pre></li></ol></li><li>返回值类型为reslutMap</li><li>上述方法同理于,在sql语句中起别名,但上述xml配置需要解析,效率不如直接写sql语句高</li></ol></li><li><p>注意:mybatis再执行sql的时候,默认的是手动提交,可以再创建sqlSession对象的时候传入参数true.则可以设置自动提交</p></li><li><p>每个配置文件中出现大量重复的sql语句,例如select * from user,我们可以使用<include>标签</include></p><ol><li><include>1. refid:根据id值引入</include></li><li>注意:写的时候不要写分号,否则无法评价<h3 id="mybatis中表间关系"><a href="#mybatis中表间关系" class="headerlink" title="mybatis中表间关系"></a>mybatis中表间关系</h3></li></ol></li><li><p>一对一</p></li><li><p>一对多</p><ol><li>例如,查询一个用户,并显示他的所有账户信息</li></ol></li><li><p>多对一</p><ol><li>mybatis中不存在多对一的关系<ol><li>因为mybatis是java框架,面向对象的编程思想,而一个实体类对象,就只能对应另一个实体类对象</li></ol></li><li>例如查询所有账户所对应的用户信息.</li></ol></li><li><p>多对多</p><h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3></li><li><p>延迟加载</p><ol><li>使用到数据的时候才发起查询,不使用的时候不发起,也称懒加载</li><li>通常运用于:一对多,多对多</li><li>延迟加载的是一个对象时:<ol><li><settings>标签:<ol><li><setting>标签<ol><li>name属性:<ol><li>lazyLoadingEnabled:</li><li>agressiveLazyLoading:为假时,每个方法调用都会是按需加载</li></ol></li><li>value属性:boolean</li></ol></setting></li></ol></settings></li></ol></li><li>延迟加载的是对象集合时:<ol><li>collection标签<ol><li>属性select查询的条件,全类名+方法名</li><li>column:根据什么查询</li></ol></li></ol></li></ol></li><li><p>立即加载</p><ol><li>不管用不用,一调用方法,则立即加载</li><li>通常运用于:一对一,多对一<br>####缓存</li></ol></li><li><p>缓存的优点</p><ol><li>存在于内存中的临时数据</li><li>减少数据库的交互次数,提高执行效率</li><li>经常查询并且不经常改变的,数据正确与否对最终结果影响不大的适合使用缓存的方式来存储 </li></ol></li><li><p>一级缓存</p><ol><li>SqlSession对象的缓存,执行查询后,查询的结果会同时存入到SqlSession提供的一片区域中,一个Map集合.当我们再次查询同样的数据后,mybatis会先去SqlSession中查询是否已有,有的话就直接返回</li><li>当SqlSession对象消失时,mybatis的一级缓存也就消失了.sqlSession.clearCache也可以清空缓存</li><li>当数据库数据发生更改,一级缓存如何同步?<ol><li>当调用sqlSession的修改,添加,删除,commit,close方法时,一级缓存会被自动清空</li></ol></li></ol></li><li><p>二级缓存</p><ol><li>指的是SqlSessionFactory对象的缓存,是由同一个SqlSessionFactory对象创建的SqlSession共享其缓存</li><li>使用步骤:<ol><li>让mybatis框架支持二级缓存(在主配置文件中配置)<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>​    2. 让当前映射文件支持二级缓存(需要使用二级缓存的接口映射配置文件中)</li></ol></li></ol></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure><pre><code>3. 让当前操作支持二级缓存(在select标签中配置)    1. useCache属性:true</code></pre><ol start="3"><li>注意事项:<ol><li>二级缓存中存放的是数据,不是对象,每次取值会创建不同的对象</li></ol></li></ol><h3 id="注解版"><a href="#注解版" class="headerlink" title="注解版"></a>注解版</h3><ol><li><p>不需要接口的映射配置文件.在接口上直接加上@Select注解,并指定sql语句,同时需要在主配置文件中配置映射,使用class属性指定dao接口的全类名</p></li><li><p>mybatis支持.写dao实现类    </p></li><li><p>@Results注解:相当于resultMap,创建一个数据库列名和实体类属性的映射</p><ol><li>value属性:<ol><li>一个@Resulet的数组</li><li>@Result<ol><li>id属性:是否为主键boolean类型,默认false</li><li>colum属性:数据库列名</li><li>property属性:实体类属性名</li><li>one属性:一对一专用<ol><li>one=@One()</li><li>@One标签:<ol><li>select属性:<ol><li>指定查询方法的全类名</li></ol></li><li>fetchType属性:EAGER,LAZY<ol><li>指定使用延迟查询还是立即查询</li></ol></li></ol></li></ol></li><li>many属性:一对多专用<ol><li>many=@Many()</li><li>@many标签:<ol><li>select属性:<ol><li>指定查询方法的全类名</li></ol></li><li>fetchType属性:EAGER,LAZY<ol><li>指定使用延迟查询还是立即查询</li></ol></li></ol></li></ol></li></ol></li></ol></li><li>id属性:用于给定一个唯一标识符</li></ol></li><li><p>@ResultMap:引入一个返回结果的封装类型</p></li><li><p>二级缓存:</p><ol><li>步骤:在主配置文件全局开启二级缓存</li><li>在接口上加@CacheNamespace(blocking=true)</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="codeStudy" scheme="http://yoursite.com/categories/codeStudy/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="hide" scheme="http://yoursite.com/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title>MVC</title>
    <link href="http://yoursite.com/2020/04/19/MVC/"/>
    <id>http://yoursite.com/2020/04/19/MVC/</id>
    <published>2020-04-19T08:09:57.000Z</published>
    <updated>2020-05-17T14:43:32.475Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="MVC-开发模式"><a href="#MVC-开发模式" class="headerlink" title="MVC:开发模式"></a>MVC:开发模式</h2><ol><li><p>jsp演变历史</p><ol><li>早期只有servlet,只能使用response输出标签数据,非常麻烦</li><li>后来有了jsp,简化了Servlet的开发,如果过度使用jsp,在jsp中写大量的Java代码,又写html,造成难以维护,难以分工协作</li><li>再后来.java的web开发,借鉴mvc开发模式,使得程序的设计更加合理<br> 2.MVC:    Model View Controller</li><li>M:Model,模型.JavaBean<ol><li>完成具体的业务操作,如:查询数据库,封装对象</li></ol></li><li>V:view,视图.jsp<ol><li>展示数据</li></ol></li><li>C:Controller,控制器.Servlet<ol><li>获取用户的输入</li><li>调用模型</li><li>将数据交给视图进行展示</li></ol></li></ol></li><li><p>优缺点:</p><ol><li><p>优点:  </p><ol><li>耦合性低,便于维护,可以利于分工协作</li><li>重用性高</li></ol></li><li><p>缺点:  </p><ol><li>使得项目架构变得复杂,对开发人员要求高<h4 id="需要在JSP页面写少量的java代码-EL表达式的诞生"><a href="#需要在JSP页面写少量的java代码-EL表达式的诞生" class="headerlink" title="需要在JSP页面写少量的java代码(EL表达式的诞生)"></a>需要在JSP页面写少量的java代码(EL表达式的诞生)</h4></li></ol></li><li><p>概念:Expression Language</p></li><li><p>作用:替换和简化jsp页面中java代码的编写</p></li><li><p>语法:${}</p></li><li><p>注意:</p><ol><li>jsp默认支持el表达式,如果需要忽略el表达式<ol><li>设置jsp中的page指令:isElIgnored=”true”,忽略当前jsp页面中所有的el表达式</li><li>${表达式}:忽略当前这个El表达式</li></ol></li></ol></li><li><p>使用:</p><ol><li>运算<ol><li>运算符:<ol><li>算数运算符: +  -  *  /(div) %(mod)</li><li>比较运算符:&gt; &lt;  &gt;=  &lt;= !=</li><li>逻辑运算符:&amp;&amp;(and)  ||(or)  !(not)</li><li>空运算符:empty<ol><li>功能:用于判断字符串,集合,数组对象是否为null并且长度是否为0</li><li>${empty 判断对象} boolean </li></ol></li></ol></li></ol></li><li>获取值<ol><li>El表达式只能从域对象中获取值</li><li>语法:<ol><li>${域名.键名}:从指定域中获取指定键值<ol><li>域名称:<ol><li>pageScope        –&gt;pageContext</li><li>requestSCope        –&gt;request</li><li>sessionScope        –&gt;session</li><li>applicationScope    –&gt;application(ServletContext)<ol><li>举例:在request域中存储了name=章三</li><li>获取${requestScope.name}</li></ol></li></ol></li><li>${键名}:表示依次从最小的域中查找是否有该键对应的值,直到找到为止</li><li>获取对象.List集合,Map集合的值<ol><li>对象:${域名称.键名.属性名}<ol><li>本质上回去调用对象的getter方法<ol><li>属性名:是getter方法去掉了get前缀并把后面的首字母变为小写,为属性,并不是成员变量</li><li>如getName属性为name,但并不是成员变量name</li></ol></li></ol></li><li>List集合:${域名称.键名[索引]}</li><li>Map集合:<ol><li>${域名称.键名.key名称}</li><li>${域名称.键名[“key名称”]} </li></ol></li></ol></li></ol></li></ol></li></ol></li><li>隐式对象:<ol><li>El表达式中有11个隐式对象</li><li>pageContext:<ol><li>获取jsp其他八个内置对象<ol><li>${pageContext.requst.contextPath}:动态获取虚拟目录</li><li>MVC的具体表现.动态的获取虚拟路径.方便程序的维护<h4 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h4></li></ol></li></ol></li></ol></li></ol></li><li><p>概念:JavaServer Pages Tag Library JSP标准标签库</p><ol><li>是由Apache组织提供的开源的免费的jsp标签    &lt;标签&gt;</li></ol></li><li><p>作用:用于简化和替换jsp页面上的java代码</p></li><li><p>使用步骤</p><ol><li>导入jstl相关的jar包</li><li>引入标签库:taglib指令:&lt;%@ taglib %&gt;</li><li>使用标签</li></ol></li><li><p>常用的标签</p><ol><li>if:相当于java代码的if语句<ol><li>属性:<ol><li>test必须属性,接受一个boolean表达式<ol><li>如果为true,则显示if标签体内容,如果为false,则不显示<ol><li>一般情况下,test属性值会结合el表达式一起使用</li></ol></li></ol></li><li>注意:c:if标签没有else情况,想要else情况,必须多定义一个c:if</li></ol></li></ol></li><li>choose:相当于java代码的switch语句<ol><li>使用choose标签声明            相当于switch声明</li><li>使用when标签做判断            相当于case</li><li>使用otherwise标签做其他情况的声明    相当于default</li></ol></li><li>foreach:相当于java代码的for语句<ol><li>完成重复的操作<ol><li>for(i=0;i&lt;10;i++){}<ol><li>属性:<ol><li>begin:开始值</li><li>end:结束值</li><li>var:临时变量</li><li>step:步长</li><li>varStatus:循环状态对象<ol><li>index:容器中元素的索引,从0开始</li><li>count:循环次数,从1开始</li></ol></li></ol></li></ol></li></ol></li><li>遍历容器<ol><li>List<User> list;<br> for(User user: list){}<ol><li>属性:<ol><li>items:容器对象</li><li>var:容器中元素的临时变量</li><li>varStatus:循环状态对象<ol><li>index:容器中元素的索引,从0开始</li><li>count:循环次数,从1开始</li></ol></li></ol></li></ol></User></li></ol></li></ol></li></ol></li></ol></li></ol><p>​         </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="codeStudys" scheme="http://yoursite.com/categories/codeStudys/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="hide" scheme="http://yoursite.com/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="http://yoursite.com/2020/04/19/Linux/"/>
    <id>http://yoursite.com/2020/04/19/Linux/</id>
    <published>2020-04-19T08:09:39.000Z</published>
    <updated>2020-05-17T14:43:27.123Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>一款开源的操作系统,免费、稳定、高效,且处理高并发很强悍</li><li>应用领域:服务器、嵌入式应用、桌面应用领域<ol><li>相较于别的操作系统更加安全、稳定,因为linux是开源的,且由所有Linux爱好者 共同维护,发现bug马上就会修复,且其内核可以由使用者自定义裁剪或扩展,使其应用更加的个性化</li></ol></li><li>平时我们说的是Linux的内核,我们使用的是各个厂商对Linux的扩展,产生不同的Linux发行版本,我用的是CentOS,常用的还有Redhat和Ubuntu<h3 id="Linux和Unix以及Windows"><a href="#Linux和Unix以及Windows" class="headerlink" title="Linux和Unix以及Windows"></a>Linux和Unix以及Windows</h3></li><li>Unix最先诞生,由B语言基础演变成了C语言开发,功能进一步强大,然后由各大互联网公司买来制作成各自的Unix发行版本,但收费且费用很高,然后促进的GUN计划(自己开发软件层),Linux在GUN计划的推动下诞生,Linux在Minix(Unix的一个发行版)的基础上开发</li><li>GUN计划<ol><li>人—&gt;硬件….实现在人机之间的软件层软件自由.由所有程序员共同发展.</li><li>人—软件—Shell—操作系统—&gt;硬件<h4 id="Linux和Windows"><a href="#Linux和Windows" class="headerlink" title="Linux和Windows"></a>Linux和Windows</h4><h3 id="我使用的与Linux相关的软件"><a href="#我使用的与Linux相关的软件" class="headerlink" title="我使用的与Linux相关的软件"></a>我使用的与Linux相关的软件</h3></li></ol></li><li>虚拟机 VMware</li><li>CentOS</li><li>远程登录XShell5</li><li>文件共享XFTP6</li><li>vmtools<ol><li>可以直接粘贴命令在windows和centos系统之间</li><li>可以设置windows和centos的共享文件夹<ol><li>虚拟机设置 vm–&gt;setting,设置选项菜单为always enable</li><li>windows和centos可共享文件的目录</li><li>在centos的/mnt/hgfs/下<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3></li></ol></li></ol></li><li>在Linux中一切皆文件</li><li>Linux采用树状的目录结构<ol><li><strong>/bin:存放最常使用的命令</strong></li><li>/sbin:存放的是系统管理员使用的系统管理程序(超级管理员的命令)</li><li><strong>/home:存放普通用户的主目录,一般以用户名命名</strong></li><li><strong>/root:系统管理员目录</strong></li><li>/lib:开机所需要的动态链接共享库,应用程序也需</li><li>/lost+found:非法关机后存放一些文件</li><li><strong>/etc:存放系统管理的配置文件</strong></li><li><strong>/usr:许多应用程序和文件存放在此目录下类似于program files目录</strong></li><li><strong>/boot:存放Linux的核心文件(内核)</strong></li><li>/proc:系统内存的映射,一个虚拟目录,可以访问这个目录获取系统信息</li><li>/srv:service的缩写,存放一些服务启动后需要提取的数据</li><li>/sys</li><li><strong>/tmp:临时文件目录,存放临时文件的</strong></li><li>/dev:存放设备的,类似于设备管理器</li><li><strong>/media:存放媒体设备的.当Linux识别到媒体设备后,会把识别的设备挂载到这个目录下</strong></li><li><strong>/mnt:系统提供该目录为了让用户临时挂载别的文件系统的,可以将外部的存储挂载在/mnt/上,然后进入该目录就可以查看里的内容</strong></li><li><strong>/opt:安装软件摆放的目录,安装包</strong></li><li><strong>/usr/loacl:给主机额外安装软件的所安装的目录,安装完成就存放的目录/</strong></li><li><strong>/var:经常存放不断修改的文件,一般将日志文件存放在此文件夹下</strong></li><li>/selinux:SELinux是一种安全子系统,他能控制程序只访问特定文件<h3 id="远程登录和远程上传和下载"><a href="#远程登录和远程上传和下载" class="headerlink" title="远程登录和远程上传和下载"></a>远程登录和远程上传和下载</h3></li></ol></li><li>Linux一般作用于服务器领域,而服务器一般在各个厂商的机房中,所以需要远程登录到机房的Linux中…..XShell可以实现远程登录,XFTP可以远程上传和下载文件的<h4 id="XShell"><a href="#XShell" class="headerlink" title="XShell"></a>XShell</h4></li><li>没有中文乱码问题.支持SSH1,SSH2和TELNET协议</li><li>使用XShell的前提是,Linux服务器必须开启sshd服务..22号端口<h4 id="XFTP"><a href="#XFTP" class="headerlink" title="XFTP"></a>XFTP</h4></li><li>用于文件远程上传和下载<h3 id="vi-和-vim"><a href="#vi-和-vim" class="headerlink" title="vi 和 vim"></a>vi 和 vim</h3><h4 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h4></li><li>所有的Linux系统都会内建vi编辑器</li><li>现在不常用vi编辑器<h4 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h4></li><li>具有程序编辑的能力,可以看成vi的增强版</li><li>可以主动的以字体颜色辨别语法的正确性,方便程序设计</li><li>代码补充、编译及错误跳转等方便编程的功能特别丰富<h5 id="vim的使用"><a href="#vim的使用" class="headerlink" title="vim的使用"></a>vim的使用</h5><h6 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h6></li><li>以vim打开一个文档,直接进入的模式<h6 id="插入模式-编辑模式"><a href="#插入模式-编辑模式" class="headerlink" title="插入模式/编辑模式"></a>插入模式/编辑模式</h6></li><li>该模式下能输入内容<h6 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h6></li><li>此模式,提供相关指令,完成读取,存盘,替换,退出vim,显示行号等操作<h4 id="vi和vim模式的相互切换"><a href="#vi和vim模式的相互切换" class="headerlink" title="vi和vim模式的相互切换"></a>vi和vim模式的相互切换</h4></li><li>由正常模式—-&gt;编辑模式:i</li><li>由正常模式—-&gt;命令行模式: 输入:</li><li>常用的命令行的命令<ol><li>wq:保存并退出</li><li>q:退出</li><li>q!:强制退出<h5 id="vi和vim中常用的快捷键"><a href="#vi和vim中常用的快捷键" class="headerlink" title="vi和vim中常用的快捷键"></a>vi和vim中常用的快捷键</h5></li></ol></li><li>复制: nyy 复制几行就写几,如5yy,从当前行向下复制5行……只能在正常模式使用</li><li>粘贴: p</li><li>删除: ndd 删除几行就写几,如5yy,从当前行向下删除5行……只能在正常模式使用</li><li>查找:在命令行下 输入 /关键字,按回车查找,输入n就是查询下一个……命令行</li><li>设置文件的行号,取消文件的行号:命令行下:set nu 和 set nonu</li><li>到达文首:gg……正常模式</li><li>到达文尾:G……正常模式</li><li>撤销:u    ……正常模式</li><li>光标移动到第n行:输入n,shift+g<h3 id="关机-amp-重启"><a href="#关机-amp-重启" class="headerlink" title="关机&amp;重启"></a>关机&amp;重启</h3><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><ol><li>shutdown -h now:立即关机</li><li>shutdown -h 1:1分钟后关机</li><li>shutdown -r now:立即重启<h4 id="halt"><a href="#halt" class="headerlink" title="halt"></a>halt</h4></li></ol></li><li>直接使用,效果等价于关机<h4 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h4></li><li>重启<h4 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h4></li><li>把内存的数据保存到磁盘上,关机前需要执行的命令<h3 id="用户登录和注销"><a href="#用户登录和注销" class="headerlink" title="用户登录和注销"></a>用户登录和注销</h3></li><li>登录时尽量少用root账号登录,因为权限过大,避免操作失误.一般使用普通用户登录,然后再使用”su -username”命令来切换成管理员身份</li><li>在终端中输入logout即可注销</li></ol><ul><li>注意: logout在运行级别5下无效,在3下才有效</li><li>运行级别:<ol><li>级别 0 :关机</li><li>级别 1 :单用户(找回丢失密码)</li><li>级别 2 :多用户无网络服务</li><li>级别 3 :多用户有网络服务</li><li>级别 4 :保留</li><li>级别 5 :图形界面</li><li>级别 6 :重启<h3 id="指令篇"><a href="#指令篇" class="headerlink" title="指令篇"></a>指令篇</h3><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4></li></ol></li></ul><ol><li>家目录:创建用户后,会在/home下创建各自的家目录,当用户登录后,会自动的进入到各自的家目录</li><li>Linux系统是一个多用户多任务的操作系统,任何一个使用系统资源的用户,都必须像系统管理员申请一个账号,然后以这个账号的身份进入系统</li><li>Linux的用户需要至少要属于一个组<h5 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h5></li><li>添加用户: useradd [选项] 用户名(添加成功后会自动在/home/创建一个和用户名一样的家目录)<ol><li>操作:<ol><li>d: 指定目录,为新用户指定一个家目录</li><li>g: 添加到指定组</li></ol></li></ol></li><li>指定/修改密码 : passwd 用户名</li><li>删除用户: userdel 用户名(一般保存家目录)<ol><li>操作:<ol><li>r: 同时删除家目录</li></ol></li></ol></li><li>查询用户信息: id 用户名<ol><li>返回值:<ol><li>uid(用户id) gid(组id) 组(组名)</li></ol></li></ol></li><li>切换用户:su -切换用户名(一般用于当前用户权限不够,可通过su -指令切换到更高权限的用户)<ol><li>细节: 从权限高的用户切换到权限低的用户,无需密码,返回到原来用户时使用exit</li></ol></li><li>查看当前用户/登录用户:who am i<h4 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h4></li><li>Linux使用组对用户权限进行管理,系统可以对由共性的多个用户进行统一的管理</li><li>用户和组的相关文件<ol><li>/etc/passwd<ol><li>用户的配置文件,记录用户的各种信息<ol><li>每行的含义: 用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</li></ol></li></ol></li><li>/etc/shadow<ol><li>口令的配置文件<ol><li>每行的含义: 登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</li></ol></li></ol></li><li>/etc/group<ol><li>组(group)的配置文件,记录Linux包含的组的信息<ol><li>每行的含义: 组名:口令:组标识号:组内用户列表<h5 id="指令-1"><a href="#指令-1" class="headerlink" title="指令"></a>指令</h5></li></ol></li></ol></li></ol></li><li>新增组: groupadd 组名</li><li>删除组: groupdel 组名</li><li>修改组: usermod -g 用户组 用户名<h3 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h3></li></ol><ul><li><p>运行级别:</p><ol><li>级别 0 :关机</li><li>级别 1 :单用户(找回丢失密码)</li><li>级别 2 :多用户无网络服务</li><li>级别 3 :多用户有网络服务</li><li>级别 4 :保留</li><li>级别 5 :图形界面</li><li>级别 6 :重启</li></ol></li><li><p>init 来切换不同的运行级别 init<a href="重启后不报存">012356</a></p></li><li><p>系统的运行级别配置文件 /etc/inittab(CentOS7 以后该配置文件为空)</p></li><li><p>CentOS7以后使用systemctl命令</p><table><thead><tr><th><strong>systemctl</strong></th><th align="left"><strong>命令 说明</strong></th></tr></thead><tbody><tr><td>systemctl get-default</td><td align="left">获得当前的运行级别</td></tr><tr><td>systemctl set-default multi-user.target</td><td align="left">设置默认的运行级别为mulit-user</td></tr><tr><td>systemctl isolate multi-user.target</td><td align="left">在不重启的情况下，切换到运行级别mulit-user下</td></tr><tr><td>systemctl isolate graphical.target</td><td align="left">在不重启的情况下，切换到图形界面下</td></tr><tr><td>应用实例:</td><td align="left"></td></tr><tr><td>1. root用户如何找回密码(远程)</td><td align="left"></td></tr><tr><td>1. 在加载前,编辑一些界面e</td><td align="left"></td></tr></tbody></table></li></ul><h3 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h3><ol><li>可以了解某个指令的具体语法<h4 id="man-获得帮助信息"><a href="#man-获得帮助信息" class="headerlink" title="man 获得帮助信息"></a>man 获得帮助信息</h4></li><li>man [命令或配置文件]<h4 id="help-命令"><a href="#help-命令" class="headerlink" title="help [命令]"></a>help [命令]</h4></li></ol><h3 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a>文件目录类</h3><h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><ol><li>显示当前工作目录的绝对路径<h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4></li><li>ls [选项]   [目录或是文件]</li><li>常用选项<ol><li>-a :显示当前目录的所有文件和目录,包括隐藏目录</li><li>-l :以列表的形式显示信息<h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4></li></ol></li><li>cd [参数]<ol><li>常用参数<ol><li>绝对路径和相对路径</li><li>cd ~ /cd :     回到自己的家目录</li><li>cd .. 返回上一级目录<h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4></li></ol></li></ol></li><li>创建目录</li><li>mkdir [选项] 要创建的目录<ol><li>常用选项<ol><li>-p:创建多级目录<h4 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h4></li></ol></li></ol></li><li>删除指定空目录</li><li>rmdir [选项] 要删除的空目录</li><li><strong>rmdir只能删除空目录,如果目录下有内容无法删除,如果要删除非空目录,则需要使用rm-rf删除</strong><h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4></li><li>创建空文件</li><li>touch 文件名称<h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4></li><li>拷贝文件到指定目录</li><li>cp [选项] source destination<ol><li>常用选项<ol><li>-r : 递归复制整个文件夹</li></ol></li><li>常见问题 : 目标目录存在该文件或者文件夹,则会提示,使用    <strong>\ cp命令    强制覆盖不提示</strong> <h4 id="rm指令"><a href="#rm指令" class="headerlink" title="rm指令"></a>rm指令</h4></li></ol></li><li>rm指令移除文件或目录</li><li>rm [选项] 要删除的文件或目录<ol><li>常用选项<ol><li>-r : 递归删除整个文件夹</li><li>-f :  强制删除不提示<h4 id="mv指令"><a href="#mv指令" class="headerlink" title="mv指令"></a>mv指令</h4></li></ol></li></ol></li><li>移动文件与目录或重命名</li><li>mv oldNameFile newNameFile    (重命名)</li><li>mv /temp/movefile /targetFolder    (移动文件)<h4 id="cat指令"><a href="#cat指令" class="headerlink" title="cat指令"></a>cat指令</h4></li><li>查看文件内容</li><li>cat [选项] 要查看的文件<ol><li>常用选项:<ol><li>-n : 显示行号</li></ol></li></ol></li><li>cat只能浏览文件而不能修改文件,为了浏览方便,一般会带上管道指令 | more(分页显示指令)<ol><li>管道指令 : | 相当于数据库的连接,,,,是在”|”前的指令执行完的基础上执行后面的指令<h4 id="more指令"><a href="#more指令" class="headerlink" title="more指令"></a>more指令</h4></li></ol></li><li>基于vi编辑器的文本过滤器,全屏显示,按分页的方式显示文本内容,内置了许多快捷键</li><li>more  要查看的文件<ol><li>常用快捷键:<ol><li>space : 向下翻一页</li><li>Enter : 向下翻一行</li><li>q : 立刻离开,不再显示该页内容</li><li>Ctrl+F : 向下滚动一屏</li><li>Ctrl+B : 返回上一屏</li><li>= : 输出当前行的行号</li><li>f : 输出文件名和当前行号<h4 id="less指令"><a href="#less指令" class="headerlink" title="less指令"></a>less指令</h4></li></ol></li></ol></li><li>和more指令类似,分屏显示文件内容,但比more更夹高效,每次只加载屏幕显示的内容,其余部分,用时才加载(类似于懒加载)</li><li>less  要查看的文件<ol><li>常用快捷键:<ol><li>space : 向下翻一页</li><li>pagedown : 向下翻一页</li><li>pageup : 向上翻一页</li><li>/字符串 : 向下搜寻[字符串]的功能 : n向下查找(查找下一个),N向上查找(查找上一个</li><li>?字符串 : 向上的功能 : n向上查找(查找上一个),N向下查找(查找下一个)</li><li>q : 立刻离开,不再显示该页内容<h4 id="gt-指令"><a href="#gt-指令" class="headerlink" title="&gt; 指令"></a>&gt; 指令</h4></li></ol></li></ol></li><li>输出重定向 (覆盖目标文件文本内容)</li><li>实例<ol><li>ls -l &gt; 文件 (将列表内容写入到文件中(覆盖))</li><li>cat 文件1 &gt; 文件2 (将文件1写入到文件2(覆盖))<h4 id="gt-gt-指令"><a href="#gt-gt-指令" class="headerlink" title="&gt;&gt;指令"></a>&gt;&gt;指令</h4></li></ol></li><li>追加(在目标文件后追加内容)<ol><li>ls -l &gt;&gt; 文件 (将列表内容追加到文件中)<h4 id="echo指令"><a href="#echo指令" class="headerlink" title="echo指令"></a>echo指令</h4></li></ol></li><li>输出内容到控制台</li><li>echo [选项]  [输出内容]<h4 id="head指令"><a href="#head指令" class="headerlink" title="head指令"></a>head指令</h4></li><li>显示文件的开头部分内容,默认显示文件前十行内容</li><li>head 文件(查看文件前十行内容)</li><li>head -n 5 文件(查看文件前5行内容)<h4 id="tail指令"><a href="#tail指令" class="headerlink" title="tail指令"></a>tail指令</h4></li><li>用于输出文件中尾部的内容,默认情况下tail指令显示文件的后十行内容</li><li>tail 文件(功能描述:查看文件的后十行内容)</li><li>tail -n 5 文件(功能描述:查看文件后五行内容,5可以是任意行数)</li><li><strong>tail -f 文件(实时追踪该文档的所有更新)重点</strong><h4 id="ln指令"><a href="#ln指令" class="headerlink" title="ln指令"></a>ln指令</h4></li><li>软链接也叫符号连接,类似于windows里的快捷方式,主要存放了链接其他文件的路径</li><li>ln -s [原文件或目录]  [软连接名] (给原文件创建一个软链接)</li><li>但是pwd过后,所在的目录是在软连接目录下(相当于在桌面上打开了一个文件,可以看见其中的各种目录结构,但是还在桌面上)</li><li>删除 rm -rf 软连接名<h4 id="history指令"><a href="#history指令" class="headerlink" title="history指令"></a>history指令</h4></li><li>查看已经执行过的历史命令,也可以执行历史指令</li><li>history(显示所有)</li><li>history 数字(显示n个最近执行的指令)</li><li>!n (执行历史执行编号为n的指令)<h3 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h3><h4 id="date指令-显示当前日期"><a href="#date指令-显示当前日期" class="headerlink" title="date指令 显示当前日期"></a>date指令 显示当前日期</h4></li><li>date (显示当前时间)</li><li>date +%Y (显示当前年份)</li><li>date +%m(显示当前月份)</li><li>date +%d(显示当前是哪一天)</li><li>date “+%Y-%m-%d %H:%M:%S”(显示年月日时分秒)</li><li>date -s  字符串时间 (2018-10-10 11:22:33)符号不能变<h4 id="cal指令"><a href="#cal指令" class="headerlink" title="cal指令"></a>cal指令</h4></li><li>查看日历指令</li><li>cal [选项] 不加选项,显示本月日历</li><li>cal 2020 显示2020年日历<h3 id="搜索查找类"><a href="#搜索查找类" class="headerlink" title="搜索查找类"></a>搜索查找类</h3><h4 id="find指令"><a href="#find指令" class="headerlink" title="find指令"></a>find指令</h4></li><li>find指令将从指定目录下递归的遍历各个子目录,将满足条件的文件或者目录显示在终端</li><li>find [搜索范围]  [选项]<ol><li>常用选项<ol><li>-name 查询方式, 按照指定的文件名查找模式,查找文件</li><li>-user 用户名, 查找指定用户名下的所有文件</li><li>-size 文件大小,按照指定的文件大小查找文件<ol><li>+n,-n,=n,分别标识大于,小于,等于文件大小,注意要加单位<h4 id="locate指令"><a href="#locate指令" class="headerlink" title="locate指令"></a>locate指令</h4></li></ol></li></ol></li></ol></li><li>快速定位文件路径,利用事先建立的数据库实现快速定位给定文件(系统中的所有文件名称和路径),,查询速度较快,但为了保证结果的准确度,管理员必须定期更新locate数据库</li><li>locate 搜索文件</li><li>locate指令是基于locate数据库进行查询,所以第一次运行前,必须使用updatedb指令,创建数据库<h4 id="grep指令和管道符号"><a href="#grep指令和管道符号" class="headerlink" title="grep指令和管道符号 |"></a>grep指令和管道符号 |</h4></li><li>grep过滤查找,管道符,”|”,标识将前一个命令的处理结果输出传递给后面的命令处理</li><li>grep [选项] 查找内容 源文件<ol><li>常用选项<ol><li>-n 显示匹配行及行号</li><li>-i 忽略字母大小写<h3 id="压缩和解压类"><a href="#压缩和解压类" class="headerlink" title="压缩和解压类"></a>压缩和解压类</h3><h4 id="gzip指令"><a href="#gzip指令" class="headerlink" title="gzip指令"></a>gzip指令</h4></li></ol></li></ol></li><li>压缩文件</li><li>gzip 文件 (压缩文件,只能将文件压缩为*.gz文件)<h4 id="gunzip指令"><a href="#gunzip指令" class="headerlink" title="gunzip指令"></a>gunzip指令</h4></li><li>解压文件</li><li>gunzip 文件 (压缩文件,只能将文件压缩为*.gz文件)<h4 id="zip指令"><a href="#zip指令" class="headerlink" title="zip指令"></a>zip指令</h4></li><li>压缩文件</li><li>zip [选项] XXX.zip 目录/文件 将要压缩文件的内容 (压缩文件和目录的命令)<ol><li>常用选项<ol><li>-r : 递归压缩,即压缩目录<h4 id="unzip指令"><a href="#unzip指令" class="headerlink" title="unzip指令"></a>unzip指令</h4></li></ol></li></ol></li><li>解压文件</li><li>unzip  [选项] XXX.zip 目录/文件(解压缩文件)<ol><li>常用选项<ol><li>-d 目录 : 指定解压后的文件存放目录<h4 id="tar-指令"><a href="#tar-指令" class="headerlink" title="tar 指令"></a>tar 指令</h4></li></ol></li></ol></li><li>打包指令,最后打包后的文件是.tar.gz文件</li><li>tar [选项] XXX.tar.gz 打包的内容 (打包目录,压缩后的文件是tar.gz类型)<ol><li>常用选项<ol><li>-c : 产生.tar打包文件</li><li>-v : 显示详细信息</li><li>-f : 指定压缩后的文件名</li><li>-z : 打包同时压缩</li><li>-x : 解包.tar文件</li></ol></li></ol></li><li>压缩文件 tar -zcvf a.tar.gz 1.txt hello.txt</li><li>解压文件 tar -zcvf a.tar.gz 1.txt hello.txt -C /home<h3 id="组的介绍-文件-与权限有关"><a href="#组的介绍-文件-与权限有关" class="headerlink" title="组的介绍(文件)与权限有关"></a>组的介绍(文件)与权限有关</h3></li><li>所有者( 文件的所有者)</li><li>所在组(文件的所在组)</li><li>其他组(除了文件的所在组的其他组)<h4 id="chgrp指令-修改文件所在组"><a href="#chgrp指令-修改文件所在组" class="headerlink" title="chgrp指令(修改文件所在组)"></a>chgrp指令(修改文件所在组)</h4></li><li>修改文件所在组</li><li>chgrp 组名 文件名<h4 id="usermod-改变用户所在组"><a href="#usermod-改变用户所在组" class="headerlink" title="usermod(改变用户所在组)"></a>usermod(改变用户所在组)</h4></li><li>改变用户所在组</li><li>usermod -g 组名 用户名</li><li>usermod -d 目录名 用户名 改变该用户登录的初始目录<h3 id="文件的权限"><a href="#文件的权限" class="headerlink" title="文件的权限"></a>文件的权限</h3></li><li>第一位: 代表文件的类型<ol><li>l    : 软连接</li><li><ul><li>: 普通文件</li></ul></li><li>d   : 目录</li><li>c   : 字符设备[键盘鼠标等]</li><li>b   : 块文件,硬盘</li></ol></li><li>2~4位: 文件所有者的权限</li><li>5~7:和文件所在组的所有组员的权限</li><li>8~10:其他组成员的权限<ol><li>r :读权限</li><li>w:写权限</li><li>x:执行权限,作用于文件代表可执行,作用与目录代表可进入该目录</li><li>-:无权限 </li></ol></li></ol><ul><li>注意: 删除文件必须对该文件有写权限不一定能删除,还需对该文件的目录有写权限才能删除该文件<h4 id="chmod-修改文件或目录的权限"><a href="#chmod-修改文件或目录的权限" class="headerlink" title="chmod(修改文件或目录的权限)"></a>chmod(修改文件或目录的权限)</h4></li></ul><ol><li>修改文件或目录的权限</li><li>第一种方式<ol><li>u:所有,,,,g:所在组,,,,o:其他人,,,,a:所有人(u,g,o的总和)<ol><li>chmod u=rwx,g=rx,o=x 文件目录名<ol><li>给所有者添加读写执行权限,给所在组添加读和执行权限,给其他人添加执行权限</li></ol></li><li>chmod o+w 文件目录名<ol><li>给其他人添加写的权限</li></ol></li><li>chmod a-x 文件目录名<ol><li>给所有人添加执行的权限</li></ol></li></ol></li></ol></li><li>第二种方式:通过数字变更权限<ol><li>r=4,w=2,x=1<ol><li>chmod 751 文件目录名<ol><li>给所有者添加读写执行权限,给所在组添加读和执行权限,给其他人添加执行权限<h4 id="chown-修改文件所有者"><a href="#chown-修改文件所有者" class="headerlink" title="chown(修改文件所有者)"></a>chown(修改文件所有者)</h4></li></ol></li></ol></li></ol></li><li>修改文件所有者</li><li>chown newowner file 改变文件所有者</li><li>chown newowner:newgroup file 改变用户的所有者和所有组</li><li>-R 如果是目录 则递归<h3 id="定时任务调度"><a href="#定时任务调度" class="headerlink" title="定时任务调度"></a>定时任务调度</h3></li><li>系统在某个时间执行特定的命令或程序</li><li>分类:<ol><li>系统工作,重要工作必须周而复始的执行</li><li>个别用户工作,如备份数据库等<h4 id="crond"><a href="#crond" class="headerlink" title="crond"></a>crond</h4></li></ol></li><li>crontab [选项]<ol><li>常用选项<ol><li>-e : 编辑crontab定时任务</li><li>-l : 查询crontab任务</li><li>-f : 删除当前用户所有crontab任务</li></ol></li></ol></li><li>快速入门:<ol><li>设置任务调度文件:/etc/crontab</li><li>设置个人任务调度.执行crontab -e 命令</li><li>输入任务到调度任务</li></ol></li><li>参数解释<h3 id="磁盘分区和挂载"><a href="#磁盘分区和挂载" class="headerlink" title="磁盘分区和挂载"></a>磁盘分区和挂载</h3></li><li>分区的方式<ol><li>mbr分区:<ol><li>老式分区方式</li><li>最多支持四个主分区</li><li>系统只能安装在主分区上</li><li>扩展分区要占一个主分区</li><li>MBR分区最大只支持2TB,但是兼容性较好</li></ol></li><li>gtp分区:<ol><li>支持无限多个主分区(但是操作系统有限制,比如windows下最多128个分区)</li><li>最大支持18EB的容量(EB=1024PB,PB=1024TB)</li><li>WIN764位以后支持gtp</li></ol></li></ol></li><li>在Linux中,硬盘以挂载在文件系统中的形式,将分区和目录结构联系起来</li><li>硬盘标号:<ol><li>IDE硬盘:老, hdx~<ol><li>例如hda3,代表第一块硬盘的第三个分区</li></ol></li><li>SCSI硬盘:新,sdx~<ol><li>例如sdb2,代表第二块硬盘的第二个分区<h4 id="lsblk-查看系统分区和挂载情况"><a href="#lsblk-查看系统分区和挂载情况" class="headerlink" title="lsblk(查看系统分区和挂载情况)"></a>lsblk(查看系统分区和挂载情况)</h4></li></ol></li></ol></li><li>查看系统分区和挂载情况(老师不离开)<h4 id="df-h-磁盘情况查询"><a href="#df-h-磁盘情况查询" class="headerlink" title="df -h(磁盘情况查询)"></a>df -h(磁盘情况查询)</h4><h4 id="du-ach-查询指定目录的磁盘占用情况"><a href="#du-ach-查询指定目录的磁盘占用情况" class="headerlink" title="du -ach(查询指定目录的磁盘占用情况)"></a>du -ach(查询指定目录的磁盘占用情况)</h4></li><li>-s指定目录占用大小总额</li><li>-h带计量单位</li><li>-a含文件</li><li>–max-depth=1 子目录深度</li><li>-c 列出明细的同时,增加汇总值<h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3></li><li>自动连接(非固定的ip)</li><li>固定ip<ol><li>修改配置文件来指定ip,并可以连接外网</li><li>编写/etc/sysconfig/network-scripts/ifcfg-eth0(第几块网卡)<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3></li></ol></li><li>每个执行的程序,都为一个进程,每个进程都有一个id号</li><li>每个进程都对应一个父进程,父进程可以复制多个子进程<h4 id="ps-显示系统执行的进程"><a href="#ps-显示系统执行的进程" class="headerlink" title="ps(显示系统执行的进程)"></a>ps(显示系统执行的进程)</h4></li><li>查看系统执行的进程,以及执行状况,可以不加参数</li><li>ps 显示的信息项:<ol><li>PID:进程识别号</li><li>TTY:终端机号</li><li>TIME:此进程所消耗CPU时间</li><li>CMD:正在执行的命令或进程名</li></ol></li><li>操作:<ol><li>-a :显示当前终端所有进程信息</li><li>-u:以用户的格式显示进程信息</li><li>-x:显示后台进程运行的参数</li></ol></li><li>系统进程参数<ol><li>%CPU:cpu占用情况</li><li>%MEM:内存占用</li><li>VSZ:占用虚拟内存</li><li>RSS:使用物理内存情况</li><li>TTY:使用的终端</li><li>STAT:进行状态<ol><li>s:休眠</li><li>r:运行</li></ol></li><li>COMMAND:进程执行时的命令行</li><li><strong>PPID:父进程号,可以使用ps -ef命令得到</strong><h4 id="kill-amp-killall-终止进程"><a href="#kill-amp-killall-终止进程" class="headerlink" title="kill&amp;killall(终止进程)"></a>kill&amp;killall(终止进程)</h4></li></ol></li><li>终止进程</li><li>kill [选项] 进程号 (通过进程号杀死进程)</li><li>killall 进程名称 (通过进程名称杀死进程,也支持通配符)</li><li>常用选项<ol><li>-9 : 强迫进程立即停止<h4 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h4></li></ol></li><li>服务本质就是进程,但是运行在后台,通常会监听某个端口,等待其他程序的请求,比如(mysql,sshd,防火墙等等),因此我们又称为守护进程</li><li>service 服务名 start|stop|restart|reload|status</li><li><strong>systemctl centos7以后使用这个</strong><h4 id="top指令-动态监控进程"><a href="#top指令-动态监控进程" class="headerlink" title="top指令(动态监控进程)"></a>top指令(动态监控进程)</h4></li><li>和ps指令相似,但是top指令可以在执行的一段时间可以更新正在运行的进程</li><li>top [选项]<ol><li>常用选项<ol><li>-d 秒数,指定每个几秒更新,默认3秒</li><li>-i:使得top指令不显示任何闲置或者僵死进程</li><li>-p:通过指定监控进程ID来只监控某个进程的状态<h3 id="软件包的管理"><a href="#软件包的管理" class="headerlink" title="软件包的管理"></a>软件包的管理</h3><h4 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h4></li></ol></li></ol></li><li>RedHat Package Manager ,互联网下载包,及安装工具<h5 id="查询已经安装的rpm列表"><a href="#查询已经安装的rpm列表" class="headerlink" title="查询已经安装的rpm列表"></a>查询已经安装的rpm列表</h5></li><li>rpm -qa | grep xx<h5 id="查询软件包是否安装"><a href="#查询软件包是否安装" class="headerlink" title="查询软件包是否安装"></a>查询软件包是否安装</h5></li><li>rpm -a xx<h5 id="查询软件包信息"><a href="#查询软件包信息" class="headerlink" title="查询软件包信息"></a>查询软件包信息</h5></li><li>rpm -qi xx<h5 id="查询软件包文件"><a href="#查询软件包文件" class="headerlink" title="查询软件包文件"></a>查询软件包文件</h5></li><li>rpm -ql<h5 id="查询文件所属软件包"><a href="#查询文件所属软件包" class="headerlink" title="查询文件所属软件包"></a>查询文件所属软件包</h5></li><li>rpm -qf 路径<h4 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h4></li><li>一个shell前端软件包管理器.基于RPM包管理,能从指定的服务器自动帮我们下载RPM包并安装,可以自动处理依赖性关系,并可以一次安装所有依赖的软件包</li><li>yum list | grep xx软件列表   查询yum服务器是否需要安装的软件</li><li>yum install xxx 安装指定的yum包</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="codeStudy" scheme="http://yoursite.com/categories/codeStudy/"/>
    
    
      <category term="hide" scheme="http://yoursite.com/tags/hide/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>jsp</title>
    <link href="http://yoursite.com/2020/04/19/jsp/"/>
    <id>http://yoursite.com/2020/04/19/jsp/</id>
    <published>2020-04-19T08:09:22.000Z</published>
    <updated>2020-05-17T14:43:21.041Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><ol><li>指令<ul><li>作用: 用于配置JSP页面,导入资源文件</li><li>格式:<br>  &lt;%@指令名称 属性名1=属性值1 属性名2=属性值2 …%&gt;</li><li>分类:<ol><li>pag    :配置JSP页面的<ul><li>contentType:等同于response.setContentType()<ol><li>设置响应体的mime类型以及字符集</li><li>设置当前jsp页面的编码(只能是高级的IDE才能生效,如果使用低级工具,则需要设置pageEncoding属性设置当前页面的字符集)</li></ol></li><li>import: 导包</li><li>errorPage:当前页面发送异常后,会自动跳转到指定的错误页面</li><li>isErrorPage:标识当前是否是错误页面<ul><li>true: 是,可以使用内置对象exception</li><li>false: 否.默认值.不可以使用内置对象exception</li></ul></li></ul></li><li>include:页面包含的,导入页面的资源文件<ul><li>&lt;%@include file=”top.jsp”%&gt;</li></ul></li><li>taglib:导入资源<ul><li>&lt;%@ taglib prefix=”c(引入不同的资源文件,值不同)” uri=”引入资源文件的URL”%&gt;<ul><li>prifix,前缀,自定义的</li></ul></li></ul></li></ol></li></ul></li><li>注释:<ol><li>html注释: <!-- -->:只能注释html代码片段</li><li>jsp注释:推荐使用<br> &lt;%– –%&gt;:可以注释所有</li></ol></li><li>内置对象  <ul><li>在jsp页面中不需要创建,直接使用的对象</li><li>一共有9个<br>   变量名                真实类型                    作用<ul><li>pageContext        pageContext                当前页面共享数据,还可以获取其他八个内置对象</li><li>request            HttpServletRequest        一次请求访问的多个资源(转发)    </li><li>session            HttpSession                一次会话的多个请求间</li><li>application        ServletContext            所有用户键共享数据</li><li>response            HttpServletResponse        响应对象</li><li>page                Object                    当前页面(Servlet)的对象 this</li><li>out                JspWriter                输出对象,数据输出到页面上</li><li>config            ServletConfig            Servlet的配置对象</li><li>exception         Throwable                异常对象</li></ul></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="codeStudy" scheme="http://yoursite.com/categories/codeStudy/"/>
    
    
      <category term="hide" scheme="http://yoursite.com/tags/hide/"/>
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="模板引擎" scheme="http://yoursite.com/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Jquery</title>
    <link href="http://yoursite.com/2020/04/19/Jquery/"/>
    <id>http://yoursite.com/2020/04/19/Jquery/</id>
    <published>2020-04-19T08:09:08.000Z</published>
    <updated>2020-05-17T14:43:16.321Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="JQuery基础"><a href="#JQuery基础" class="headerlink" title="JQuery基础"></a>JQuery基础</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念:"></a>概念:</h3><ol><li>Jquery是一个快速、简介的JavaScript框架,是继Prototype之后又一个优秀的JavaScript代码库(或JavaScript框架).JQuery设计的宗旨是”write less,Do more”,即倡导写更少的代码,做更多的失去.他封装JavaScript常用的功能代码,提供了一种边界的JavaScript设计模式,优化HTML文档操作,事件处理,动画设计,和Ajax交互  </li><li>JavaScript框架:本质上是一些JS文件,封装了JS的原生代码  </li></ol><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><ol><li><p>步骤:  </p><ol><li>下载JQuery(1代兼容ie678,2开始不兼容,3不兼容一些老的js插件(增强jq对象))</li><li>导入JQ的js文件</li><li>使用</li></ol></li><li><p>Jquery对象和JS对象的区别与转换</p><ol><li>JQ对象在操作时,会更加的方便….框架的共同优点</li><li>JQ对象和JS对象的方法不通用</li><li>两者相互转换<ol><li>JQ—&gt;JS:JQ[索引]或者JQ.get(索引)</li><li>JS—&gt;JQ:$(JQ)<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3></li></ol></li></ol></li><li><p>基本操作:</p><ol><li>事件绑定<ol><li>$(选择器).事件        //等同于使用DOM获取标签对象   去掉on</li></ol></li><li>入口函数  <ol><li>$(function(){})<ol><li>和window.onload区别<ol><li>window.onload只能定义一次,多次会被覆盖</li></ol></li></ol></li></ol></li><li>样式控制<ol><li>JQ对象.css(键值对);</li></ol></li></ol></li><li><p>分类</p><ol><li>基本选择器<ol><li>标签选择器(元素选择器)<ul><li>语法: $(“标签名”) 获得所有与标签名相同的元素对象</li></ul></li><li>id选择器<ul><li>语法: $(“#id”)    获得与id值相同的元素对象</li></ul></li><li>类选择器<ul><li>语法: $(“.class”)    获得与class值相同的元素对象</li></ul></li></ol></li><li>层级选择器<ol><li>后代选择器<ul><li>语法: $(“A B”) 获得A标签内所有的B标签对象</li></ul></li><li>子选择器<ul><li>语法: $(“A&gt;B”) 获得A标签内所有的B标签子对象    只有子,没有孙子 </li></ul></li></ol></li><li>属性选择器 <ol><li>属性名称选择器<ul><li>语法: $(“A[属性名]”) 包含指定属性的A标签对象</li></ul></li><li>属性选择器<ul><li>语法: $(“A[属性名=’值’]”) 包含指定属性等于值的A标签对象    注意单双引分离</li></ul></li><li>复合属性选择器<ul><li>语法: $(“A[属性名=’值’][]”) 包含指定的多个属性等于值的A标签对象</li></ul></li></ol></li><li>过滤选择器        理解记忆:在已有选择器上增加各种约束<ol><li>首元素选择器<ul><li>语法: $(选择器:first)获取选择的元素中的第一个元素对象</li></ul></li><li>尾元素选择器<ul><li>语法: $(选择器:last)获取选择的元素中的最后一个元素对象</li></ul></li><li>非元素选择器<ul><li>语法: $(选择器:not(selector))获取选择的元素但不包括指定元素对象</li></ul></li><li>偶数选择器<ul><li>语法: $(选择器:even)获取选择的元素中的偶数元素对象,从0开始计数</li></ul></li><li>奇数选择器<ul><li>语法: $(选择器:odd)获取选择的元素中的奇数元素对象,从0开始计数</li></ul></li><li>等于索引选择器<ul><li>语法: $(选择器:eq(index))获取选择的元素中的指定索引元素对象,从0开始计数</li></ul></li><li>大于索引选择器<ul><li>语法: $(选择器:gt(index))获取选择的元素中的指定索大于引元素对象,从0开始计数</li></ul></li><li>小于索引选择器<ul><li>语法: $(选择器:lt(index))获取选择的元素中的指定小于索引元素对象,从0开始计数</li></ul></li><li>标题选择器<ul><li>语法: $(选择器:header)获取标题元素对象,固定</li></ul></li></ol></li><li>表单过滤选择器<ol><li>可用元素选择器<ul><li>语法: $(选择器:enabled)获取可用元素对象</li></ul></li><li>不可用元素选择器<ul><li>语法: $(选择器:disabled)获取不可用元素对象</li></ul></li><li>选中选择器<ul><li>语法: $(选择器:checked)获取单选/复选框选中的元素对象</li></ul></li><li>选中选择器<ul><li>语法: $(选择器:selected)获取下拉框选中的元素对象</li></ul></li></ol></li></ol></li></ol><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><ol><li>内容操作<ol><li>html():获取/设置元素的标签体内容        原样输出,内部标签也一样</li><li>text():获取/设置元素标签体纯文本内容    只获取纯文本,标签不获取</li><li>val(): 获取/设置元素的value属性值</li><li>设置:只需导入参数即可    </li></ol></li><li>属性操作<ol><li>通用属性操作<ol><li>attr():获取/设置元素的属性</li><li>removeAttr():删除属性</li><li>prop():获取/设置元素的</li><li>removeProp():删除属性<br> *attr和prop区别?<pre><code>1. 如果操作的是元素的固有属性,用prop2. 如果操作的是元素的自定义属性,使用attr</code></pre></li></ol></li><li>对class属性操作<ol><li>addClass():添加class属性值</li><li>removeClass():删除class属性值</li><li>toggleClass():切换class属性<ul><li>若已有,则删除该属性,再次点击则恢复</li></ul></li><li>css()</li></ol></li></ol></li><li>CRUD操作<ol><li>append():父元素将子元素追加到末尾<ul><li>对象1.append(对象2):将对象2添加到对象1的内部,且在末尾</li></ul></li><li>prepend():父元素将子元素追加到开头<ul><li>对象1.prepend(对象2):将对象2添加到对象1的内部,且在开头</li></ul></li><li>appendTo():<ul><li>对象1.appendTo(对象2):将对象1添加到对象2的内部,且在末尾</li></ul></li><li>prependTo():<ul><li>对象1.prependTo(对象2):将对象1添加到对象2的内部,且在开头</li></ul></li><li>after():添加元素到元素的后边<ul><li>对象1.after(对象2):将对象2添加到对象1后边,对象1和对象2兄弟关系(并级)</li></ul></li><li>before():添加元素到元素前边<ul><li>对象1.before(对象2):将对象2添加到对象1前边,对象1和对象2兄弟关系(并级)</li></ul></li><li>insertAfter()<ul><li>对象1.insertAfter(对象2):将对象1添加到对象2后边,对象1和对象2兄弟关系(并级)</li></ul></li><li>insertBefore()<ul><li>对象1.before(对象2):将对象1添加到对象2前边,对象1和对象2兄弟关系(并级)</li></ul></li></ol></li></ol><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ol><li>隔行换色</li><li>全选和全不选</li><li>QQ表情选择</li><li>多选下拉列表左右移动</li></ol><h3 id="JQuery高级"><a href="#JQuery高级" class="headerlink" title="JQuery高级"></a>JQuery高级</h3><ol><li>动画 <ol><li>三种方式显示和隐藏元素<ol><li>默认显示和隐藏方式<ol><li>show([speed],[easing],[fn])<ol><li>参数:<ol><li>speed:动画的速度.三个预定义值:(“slow”,”normal”,”fast”)或动画持续的毫秒值</li><li>easing:用来指定切换效果,默认”swing”开始慢,中间快,后面慢,或者”linear”,匀速</li><li>fn:动画在完成时,执行的函数,每个元素执行一次</li></ol></li></ol></li><li>hide([speed],[easing],[fn])</li><li>toggle([speed],[easing],[fn])</li></ol></li><li>滑动显示和隐藏方式<ol><li>slideDown([speed],[easing],[fn])</li><li>slideUp([speed],[easing],[fn])</li><li>slideToggle([speed],[easing],[fn])</li></ol></li><li>淡入淡出显示和隐藏方式<ol><li>fadeIn([speed],[easing],[fn])</li><li>fadeOut([speed],[easing],[fn])</li><li>fadeToggle([speed],[easing],[fn])</li></ol></li></ol></li></ol></li><li>遍历<ol><li>js的遍历方式<ol><li>for(初始化值;循环结束条件;步长)</li></ol></li><li>jq的遍历方式<ol><li>jq对象.each(callback)<ol><li>语法:<ol><li>JQ对象.each(function(index,element){})’<ol><li>index:就是元素在集合中的索引</li><li>element:就是集合中每一个元素对象</li><li>this:集合中的每一个元素对象</li></ol></li></ol></li><li>回调函数返回值:<ol><li>如果当前function返回为fales,则结束循环</li><li>如果当前function返回为true,则结束本次循环,继续下次循环</li></ol></li></ol></li><li>$.each(object,[callback])</li><li>for..of:JQ 3.0以后<ol><li>同理于  增强for循环</li></ol></li></ol></li></ol></li><li>事件绑定<ol><li>JQ标准的绑定方式<ol><li>JQ对象.事件方法(回调函数);<pre><code>* 表单对象.focus()获得焦点    * 表单对象.submit()让表单提交</code></pre></li></ol></li><li>on绑定事件/off解除绑定<ol><li>JQ对象.on(“事件名称”,回调函数)</li><li>JQ对象.off(“事件名称”)    不传递,全部解绑</li></ol></li><li>事件切换:toggle<ol><li>JQ对象.toggle(fn1,fn2,fn3…)</li></ol></li></ol></li><li>案例</li><li>插件        </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="codeStudy" scheme="http://yoursite.com/categories/codeStudy/"/>
    
    
      <category term="hide" scheme="http://yoursite.com/tags/hide/"/>
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Ajax&amp;Json</title>
    <link href="http://yoursite.com/2020/04/19/Ajax-Json/"/>
    <id>http://yoursite.com/2020/04/19/Ajax-Json/</id>
    <published>2020-04-19T08:08:55.000Z</published>
    <updated>2020-05-17T14:43:06.090Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Ajax-amp-amp-Json"><a href="#Ajax-amp-amp-Json" class="headerlink" title="Ajax &amp;&amp;Json"></a>Ajax &amp;&amp;Json</h2><h3 id="AJax"><a href="#AJax" class="headerlink" title="AJax"></a>AJax</h3><ol><li><p>概念:ASynchronous JavaScript And XML &nbsp;&nbsp;&nbsp;异步的JavaScript和XML</p><ol><li>异步和同步:客户端和服务器端相互通信的基础上,提升了用户的体验…</li><li>同步:<ul><li>在执行同步代码的时候,就会给代码块上锁,其他代码必须等待执行完毕才能继续执行,,,,线程安全问题需使用,防止多线程共同同时操作一个数据,而出错</li></ul></li><li>异步:<ul><li>可并发执行.实现页面的部分更新操作</li></ul></li></ol></li><li><p>快速入门(原生JS的方式::::不怎么使用,一般使用JQ框架提供的)</p><ol><li>创建对象XMLHttpRequest<ul><li>ps:有的浏览器不支持XMLHttpRequest对象.如果不支持则需要创建ActiveXObject对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp;</span><br><span class="line"><span class="keyword">if</span> (window.XMLHttpRequest)</span><br><span class="line">  &#123;<span class="comment">// code for IE7+, Firefox, Chrome, Opera, Safari</span></span><br><span class="line">  xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;<span class="comment">// code for IE6, IE5</span></span><br><span class="line">  xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>调用方法open(method,url,async)方法规定请求的类型为GET 还是POST,文件的类型,和是否为异步请求,true 为异步请求</li><li>调用方法send,将请求发送到服务器</li></ol></li><li><p>快速入门(JQ)</p><ol><li>$.ajax()<ol><li>语法:$.ajax({键值对})    每个键值对后面加逗号,最后一个不加<ol><li>$.ajax({url:”servlet”,type:”Post”},data:{JSON格式},也可以为函数,success:function(){}或者error:function(){},dataType:设置接受响应的文本类型)</li></ol></li></ol></li><li>$.get()<ol><li>语法:$.get(url,[data],[callback],[type])<ol><li>参数:<ol><li>url:请求路径</li><li>data:请求参数</li><li>callback:回调函数</li><li>type:响应结果类型</li></ol></li></ol></li></ol></li><li>$.post()</li></ol></li><li><p>响应 </p><ul><li>需求:需要获取来自服务器的响应,如果是非XML文件则使用,XMLHttpRequest对象的responseText属性,否则则使用responseXML属性<br>xmlhttp.onreadystatechange=function(){<br>  if(xmlhttp.readyState==4&amp;&amp;xmlhttp.status==200)<pre><code>var responseText=xmlhttp.responseText</code></pre></li><li>responseText   获得字符串形式的响应数据。</li><li>responseXML    获得 XML 形式的响应数据<br>}<br>###JSON</li></ul></li><li><p>概念: JavaScript Object Natation    JavaScript对象表示法</p><ol><li>Person p=new Person();</li><li>p.setName(“章三”);</li><li>p.setAge(23);</li><li>p.setGender(“男”)</li><li>var&nbsp;&nbsp;p={“name”:”张三”,”age”:”23”,”gender”:”男”};<ul><li>json现在多用于存储和交换文本信息的语法</li><li>进行数据传输</li><li>JSON比XML更小、更快,更易解析</li></ul></li></ol></li><li><p>语法:</p><ol><li><p>基本规则</p><ul><li>数据在名称/值键值对中:json数据是由键值对构成的<ul><li>键用引号(单双都行)引起来,也可以不使用引号</li><li>值的取值类型<ul><li>数字(整数或者浮点数)</li><li>字符串(在双引号中)</li><li>逻辑值(true或者false)</li><li>数组(在方括号中)<ul><li>{“person”:[{},{},{}]}</li></ul></li><li>对象(在花括号中){“address”:{对象的成员属性}}</li><li>null</li></ul></li><li>数据由逗号分隔:多个键值对由逗号分隔开</li><li>花括号保留对象:使用{}定义json格式</li><li>方括号保存数组:[]</li></ul></li></ul></li><li><p>获取数据</p><ol><li>json对象.键名</li><li>json对象[“键名”]</li><li>数组对象[索引]</li><li>遍历<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.定义基本格式</span></span><br><span class="line"><span class="keyword">var</span> person=&#123;<span class="string">"name"</span>:<span class="string">"zhangsan"</span>,<span class="string">"age"</span>:<span class="number">23</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> ps=&#123;&#123;<span class="string">"name"</span>:<span class="string">"zhangsan"</span>,<span class="string">"age"</span>:<span class="number">23</span>&#125;,&#123;<span class="string">"name"</span>:<span class="string">"zhangsi"</span>,<span class="string">"age"</span>:<span class="number">25</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//获取person对象中的所有键和值</span></span><br><span class="line"><span class="comment">//for in 循环</span></span><br><span class="line"><span class="comment">/*for(var key in person)&#123;</span></span><br><span class="line"><span class="comment">//这样的方式获取不想.因为相当于person."name"</span></span><br><span class="line"><span class="comment">//alert(key+":"+person.key)</span></span><br><span class="line"><span class="comment">alert(key+":"+person[key]);&#125;*/</span></span><br><span class="line"><span class="comment">//获取ps中的所有值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;ps.length;i++)&#123;</span><br><span class="line"><span class="keyword">var</span> p=ps[i]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> p)&#123;</span><br><span class="line">alert(key+<span class="string">":"</span>+p[key])&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>JSON数据和Java对象的相互转化</p><ol><li>JSON解析器<ol><li>常见的解析器:JSONlib,Gson,fastjson,jackson</li><li>json转为java对象<ol><li><ol><li>导入jackson的相关jar包<ol start="2"><li>创建jackson核心对象 objectMapper</li><li>调用objectMapper的相关方法进行转换<ol><li>readValue(json字符串数据,)</li></ol></li></ol></li></ol></li></ol></li><li>java对象转换为json<ol><li>使用步骤<ol><li>导入jackson的相关jar包</li><li>创建jackson核心对象 objectMapper</li><li>调用objectMapper的相关方法进行转换<ol><li>转换方法:<ol><li>writeValue(参数1,转化的对象.Class);<ol><li>参数1:<ol><li>File:将obj对象转为json字符串,并保存到指定文件中</li><li>Writer:将obj对象转为json字符串,并保存到指定字符输出流中</li><li>OutputStream:将obj对象转为json字符串,并保存到指定字节输出流中</li></ol></li></ol></li><li>writeValueAsStream(obj):将对象转为json字符串</li></ol></li><li>注解:<ol><li>@JsonIgnore:在javaBean的成员上添加该注解,则会自动忽略该属性转换时</li><li>@JsonFormat:属性格式化<ol><li>@JsonFormat(pattern=”yyyy-MM-dd”)</li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol><p>####json字符串对象在javaScript中需要有json字符串对象转化为json对象</p><ol><li>JSON.parse(String);</li><li>json对象转为json字符串，调用JSON.stringify()方法<figure class="highlight plain"><figcaption><span>str </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">####在servlet或者jsp</span><br><span class="line">1、json对象转字符串</span><br><span class="line">&#96;&#96;&#96;JSONObject.fromObject（String ）；</span><br></pre></td></tr></table></figure></li></ol><p><b>ps注意括号内的要是String,StringBuffer 转换之后得到的json对象是空的</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"&#123;\"name\":\"小明\",\"pwd\":123456&#125;"</span>;<span class="comment">//json字符串</span></span><br><span class="line">JSONObject obj = JSONObject.fromObject(str);<span class="comment">//转换成json对象</span></span><br><span class="line">String name = obj.get(<span class="string">"name"</span>);<span class="comment">//通过方法可以获取其中元素</span></span><br></pre></td></tr></table></figure><p>2、创建json对象<br>利用toString方法可转换成字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JSONObject ob =<span class="keyword">new</span>  JSONObject();</span><br><span class="line">ob.accumulate(<span class="string">"name"</span>,<span class="string">"小明"</span>);</span><br><span class="line">ob.accumulate(<span class="string">"pwd"</span>, <span class="number">123456</span>);</span><br><span class="line">ob.accumulate(<span class="string">"age"</span>, <span class="number">18</span>);</span><br><span class="line">ob.accumulate(<span class="string">"sex"</span>, <span class="string">"男"</span>);</span><br><span class="line">String a = ob.toString();<span class="comment">//转换成字符串</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="codeStudy" scheme="http://yoursite.com/categories/codeStudy/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="hide" scheme="http://yoursite.com/tags/hide/"/>
    
      <category term="异步" scheme="http://yoursite.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Springboot</title>
    <link href="http://yoursite.com/2020/04/19/Springboot/"/>
    <id>http://yoursite.com/2020/04/19/Springboot/</id>
    <published>2020-04-19T08:08:19.000Z</published>
    <updated>2020-05-17T14:43:53.374Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><h3 id="POM文件"><a href="#POM文件" class="headerlink" title="POM文件"></a>POM文件</h3><ol><li>在pom文件中存在一个父项目,父项目中定义了需要的jar包的版本 <h4 id="spring-boot-starter-场景启动器"><a href="#spring-boot-starter-场景启动器" class="headerlink" title="spring-boot-starter(场景启动器)"></a>spring-boot-starter(场景启动器)</h4></li><li>不同的启动器,自动帮我们导入与该场景模块正常运行所依赖的所有jar<h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3></li><li>表示改类是一个springboot的配置类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span> <span class="comment">// 开启spring的自动配置功能</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(...)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;&#125;</span><br></pre></td></tr></table></figure></li><li>以前我们需要配置的东西,现在有springboot帮我们配置;@EnableAutoConfiguration开启springboot的自动配置<h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h4>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AutoConfigurationPackages.PackageImport(metadata)).getPackageName()</span><br></pre></td></tr></table></figure></li><li>导入当前注解下的类的所在包</li><li>只自动扫描在和springboot启动类所在包下的所有注解<h4 id="Import-AutoConfigurationImportSelector-class-导入自动配置类"><a href="#Import-AutoConfigurationImportSelector-class-导入自动配置类" class="headerlink" title="@Import({AutoConfigurationImportSelector.class})导入自动配置类"></a>@Import({AutoConfigurationImportSelector.class})导入自动配置类</h4>  <h3 id="springboot-开启"><a href="#springboot-开启" class="headerlink" title="springboot 开启"></a>springboot 开启</h3><h4 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h4></li><li>当一个类全是需要写回页面时,可以在类上加,就相当于@ResponseBody+@Controller <h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4></li><li>resource<ol><li>static :保存所有静态资源; js css images</li><li>templates:保存所有的模板页面;(Spring boot 默认jar包使用的时嵌入式的tomcat,不支持jsp页面,我们一般使用模板引擎(freemarker,thymeleaf))</li><li>application.properties:springboot 应用的配置文件<h4 id="springboot-配置"><a href="#springboot-配置" class="headerlink" title="springboot 配置"></a>springboot 配置</h4></li></ol></li><li>默认使用两种配置文件的格式:properties 或者yaml</li><li>作用:修改springboot自动配置的默认值<h5 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h5></li><li>以数据为中心,分级<h6 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h6></li><li>缩进表示层级关系</li><li>缩进时不允许使用tab键,只能使用空格</li><li>缩进的空格数不重要,同级元素左侧对其</li><li>大小写敏感</li><li>属性和值之间必须有空格<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"> <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"> <span class="attr">path:</span> <span class="string">/hello</span></span><br></pre></td></tr></table></figure><h6 id="值"><a href="#值" class="headerlink" title="值"></a>值</h6>####### 对象:键值对的集合(Map)</li><li>k: v:在下一行来写对象的属性值<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">people:</span></span><br><span class="line"> <span class="attr">age:</span> <span class="number">26</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">李四</span></span><br></pre></td></tr></table></figure></li><li>也可以行内写法<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">people:</span> <span class="string">&#123;age:</span> <span class="number">26</span><span class="string">,name:</span> <span class="string">李四</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure>####### 数组:一组按照次序排列的值(List,Set)</li><li>用-值表示数组中的一个元素<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">dog</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">pig</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span> <span class="string">&#123;cat,dog,pig&#125;</span></span><br></pre></td></tr></table></figure>####### 字面量:(数字,字符串,布尔)</li><li>k: v(字面量直接写)</li><li>字符串默认不需要加上单引号或者双引号<ol><li>“”:双引号(不转义字符串里的特殊字符)</li><li>‘’:单引号(转义字符串里的特殊字符)(字符串内原样输出)<h5 id="ConfigurationProperties-将配置文件中的属性和类中属性进行映射"><a href="#ConfigurationProperties-将配置文件中的属性和类中属性进行映射" class="headerlink" title="@ConfigurationProperties(将配置文件中的属性和类中属性进行映射)"></a>@ConfigurationProperties(将配置文件中的属性和类中属性进行映射)</h5></li></ol></li><li>String prefix(前缀) 定位到spring配置文件中的那个属性进行映射</li><li>yaml和properties都可以 </li><li>映射类时用@ConfigurationProperties,一项就用@Value</li></ol><h5 id="PropertySource-amp-amp-ImportResource"><a href="#PropertySource-amp-amp-ImportResource" class="headerlink" title="@PropertySource&amp;&amp;@ImportResource"></a>@PropertySource&amp;&amp;@ImportResource</h5><h6 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h6><ol><li><p>引入配置文件</p><h6 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h6></li><li><p>需要通过xml配置spring的组件时,引入spring的配置文件</p></li><li><p>但是一般都不用,一般全注解开发,@Configuration</p><h5 id="配置文件的占位符"><a href="#配置文件的占位符" class="headerlink" title="配置文件的占位符"></a>配置文件的占位符</h5></li><li><p>yml和properties都支持</p> <h5 id="Profile-多环境切换"><a href="#Profile-多环境切换" class="headerlink" title="@Profile(多环境切换)"></a>@Profile(多环境切换)</h5></li><li><p>在主配置文件编写的时候,文件名application-profile.properties/.yaml</p></li><li><p>yaml文档块,使用三个横线  — </p><ol><li>分成文档块,形成不同的Document<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">profiles:</span></span><br><span class="line">  <span class="string">dev(profile)</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>激活指定profile</p><ol><li><p>在配置文件中指定</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure></li><li><p>命令行<br> 1.测试时 </p> <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">--spring.prifiles.active</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure> <ol start="2"><li>执行jar包时<ol><li>使用java -jar springTest.jar –spring.profiles.active=dev</li></ol></li><li>也可以指定虚拟机参数</li><li>-Dspring.profiles.active=dev <h5 id="配置文件的加载位置"><a href="#配置文件的加载位置" class="headerlink" title="配置文件的加载位置"></a>配置文件的加载位置</h5></li></ol></li></ol></li><li><p>springboot启动会扫描以下位置的application.properties/.yaml作为springboot的默认配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#根目录下的config目录</span></span><br><span class="line"><span class="attr">file</span>:<span class="string">./config/ </span></span><br><span class="line"><span class="comment">#根目录</span></span><br><span class="line"><span class="attr">file</span>:<span class="string">./ </span></span><br><span class="line"><span class="attr">classpath</span>:<span class="string">/config/</span></span><br><span class="line"><span class="attr">classpath</span>:<span class="string">/</span></span><br></pre></td></tr></table></figure></li><li><p>按照优先级从高到低的顺序,所有位置的文件都会被加载,高优先级配置内容会覆盖低优先级配置的内容</p></li><li><p>也可以通过配置spring.config.location=resource来修改默认位置</p><ol><li>在项目打包完成后,在启动项目的时候,使用该命令,和其他的配置文件互补(优先级最高)</li></ol></li><li><p>如果四个位置都有配置文件,高覆盖低,其余互补</p><h5 id="外部配置的加载顺序"><a href="#外部配置的加载顺序" class="headerlink" title="外部配置的加载顺序"></a>外部配置的加载顺序</h5>  </li><li><p>命令行</p><ol><li>java -jar jar包名 –配置</li><li>多个参数使用空格隔开</li></ol></li><li><p>在jar包外,同级目录,配置文件名也得是application.yaml/properties</p></li><li><p><strong>查找顺序</strong>,<strong>由jar包外向jar包内寻找.优先加载带profile的,再加载不带profile的</strong></p><h5 id="自动配置的原理"><a href="#自动配置的原理" class="headerlink" title="自动配置的原理"></a>自动配置的原理</h5>    <h3 id="springboot的精髓"><a href="#springboot的精髓" class="headerlink" title="springboot的精髓"></a>springboot的精髓</h3></li><li><p>springboot启动会加载大量的自动配置类</p></li><li><p>我们需要看我们需要的功能有没有被springboot默认写好的自动配置类</p></li><li><p>再看自动配置类中配置了那些组件</p></li><li><p>给容器中自动配置类添加组件的时候,会从properties类中获取属性,然后再主配置文件中指定这些值</p><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><p>XXXAutoConfiguration<br>XXXProperties:再每个自动配置类上,使用@EnableConfigurationProperties绑定自此文件,并使用@ConditionalOnProperty指定profix,便可实现自动配置的文件和主配置文件的识别与绑定</p><h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表明这是一个配置类</span></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="comment">//自动的将HttpProperties配置文件注入环境</span></span><br><span class="line"><span class="comment">//配置类中可以使用 this.properties获得配置文件中的值</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;HttpProperties<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">//判断这是不是一个<span class="title">web</span>-<span class="title">servlet</span>应用</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnWebApplication</span>(<span class="title">type</span> </span>= Type.SERVLET)</span><br><span class="line"><span class="comment">//判断有没有CharacterEncodingFilter这个类</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123;CharacterEncodingFilter<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">//判断配置文件中有没有<span class="title">spring</span>.<span class="title">http</span>.<span class="title">encoding</span>这个属性,但其不必须</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">prefix</span> </span>= <span class="string">"spring.http.encoding"</span>,value = &#123;<span class="string">"enabled"</span>&#125;,matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="comment">//如果没有这个组件</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(CharacterEncodingFilter.Class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CharacterEncodingFilter <span class="title">characterEncodingFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CharacterEncodingFilter filter = <span class="keyword">new</span> OrderedCharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());</span><br><span class="line">        filter.setForceRequestEncoding(<span class="keyword">this</span>.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST));</span><br><span class="line">        filter.setForceResponseEncoding(<span class="keyword">this</span>.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE));</span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Conditional派生注解"><a href="#Conditional派生注解" class="headerlink" title="@Conditional派生注解"></a>@Conditional派生注解</h5>  </li><li><p>有则加,无则不加</p></li><li><p>自动配置类必须在一定条件才生效</p><h5 id="如何知道那个自动配置类生效了"><a href="#如何知道那个自动配置类生效了" class="headerlink" title="如何知道那个自动配置类生效了?"></a>如何知道那个自动配置类生效了?</h5></li><li><p>在配置文件中写 debug=true</p><h3 id="Springboot与日志"><a href="#Springboot与日志" class="headerlink" title="Springboot与日志"></a>Springboot与日志</h3></li><li><p>总的来说就是,不想用自带的日志框架了想换一个</p></li><li><p>spring boot 选择SLF4J 和logback</p><h4 id="日志的抽象层"><a href="#日志的抽象层" class="headerlink" title="日志的抽象层"></a>日志的抽象层</h4></li><li><p>jakarta Commons Logging</p></li><li><p>slf4j</p></li><li><p>Jboos-logging</p><h4 id="slf4j使用"><a href="#slf4j使用" class="headerlink" title="slf4j使用"></a>slf4j使用</h4></li><li><p>以后开发的时候,日志记录的方法调用,不应该直接调用日志的实现类,而是调用日志抽象层的方法,给系统导入slf4j和logback的jar</p>  </li><li><p>但是每个日志实现框架的配置文件不同.不同的有不同的配置</p><h5 id="如何让各个不同的框架统一使用slf4j"><a href="#如何让各个不同的框架统一使用slf4j" class="headerlink" title="如何让各个不同的框架统一使用slf4j"></a>如何让各个不同的框架统一使用slf4j</h5></li><li><p>将系统中的其他日志框架先排除出去</p></li><li><p>用中间包来替换原有的日志框架</p></li><li><p>我们导入slf4j</p>  </li></ol><h5 id="引入其他框架"><a href="#引入其他框架" class="headerlink" title="引入其他框架"></a>引入其他框架</h5><ol><li><p>springboot能自动适配所有的日志..</p></li><li><p>引入其他框架的时候,只需要把这个当前日志框架的所有依赖排除掉即可</p><h3 id="springboot-web"><a href="#springboot-web" class="headerlink" title="springboot-web"></a>springboot-web</h3><h4 id="springboot对静态资源的映射规则"><a href="#springboot对静态资源的映射规则" class="headerlink" title="springboot对静态资源的映射规则"></a>springboot对静态资源的映射规则</h4>  </li><li><p>所有的webjar/**,都去classpath:/META-INF/resource/webjars找</p></li><li><p>webjars:以jar包的方式引入静态资源</p></li><li><p>示例:localhost:8080/webjars/jquery/3.3.1/jquery.js</p></li><li><p>/**,访问当前项目的任何静态资源(访问时,没有响应则去找这几个目录)</p>      <p>当前项目根目录</p></li><li><p>欢迎页面</p>  <p>如果不存在自定义的欢迎页面,则去/**的映射规则下去找,如上,然后重定向到idex.html<br>如果存在欢迎页面…没找到具体操作….</p></li><li><p>喜欢图标<br>/**favicon.ico任何路径下的favicon.ico</p><h4 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h4></li><li><p>jsp,velocity,freemarker,thymeleaf</p></li><li><p>模板引擎,实际上就是对静态资源和从后台获取的动态数据的一个整和,提供了一些获取值的表达式</p>  <h5 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h5></li><li><p>语法简单,功能强大.</p></li><li><p>Thymeleaf有缓存,修改页面后,缓存会生效,不会更改页面,禁用效率更高</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.thymeleaf.cache</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure></li><li><p>请求参数,可以使用()如/crud(username=’zhangsan’)</p></li><li><p>spring-boot-start-thymeleaf(绑定的版本过低)</p></li><li><p>切换版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">thymeleaf.version</span>&gt;</span>3.0.2.RELEASE<span class="tag">&lt;/<span class="name">thymeleaf.version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">-!布局功能支持程序,thymeleaf3,必须要layout2以上--</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">thymeleaf-layout-dialect.version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">thymeleaf-layout-dialect.version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5>    </li><li><p>controller返回时,自动去classpath:templates路径下去查找</p></li><li><p>所以存放位置,为classpath:templates</p><h6 id="语法提示"><a href="#语法提示" class="headerlink" title="语法提示"></a>语法提示</h6></li><li><p>最好再html页面中,导入thymeleaf的名称空间</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="使用语法"><a href="#使用语法" class="headerlink" title="使用语法"></a>使用语法</h6></li><li><p>使用th: 任意html属性,来替换html原生属性</p></li><li><p>th:text: 改变当前元素里的文本内容</p>  <p>####### 表达式</p></li><li><p>${ }:获取变量值;OGNL表达式</p><ol><li>获取属性,调用方法</li><li>使用内置的对象<ol><li>#ctx</li><li>#vars</li><li>#locale</li><li>#request</li><li>#response</li><li>#session</li><li>servletContext</li></ol></li><li>内置的一些工具对象(一些基本的java工具类)#+工具类调用方法</li></ol></li><li><p>*{ },选择表达式:</p><ol><li>配合th:object使用<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:object</span>=<span class="string">"$&#123;session.user&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Name:<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"*&#123;firstName&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Name:<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"*&#123;lastName&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>#{ }:获取国际化内容</p></li><li><p>@{ }:替换URL内容,可以和ita表达式配合使用</p></li><li><p>~{ }</p><h4 id="扩展SpringMVC"><a href="#扩展SpringMVC" class="headerlink" title="扩展SpringMVC"></a>扩展SpringMVC</h4></li><li><p>编写配置类@Configuration,必须继承WebMvcConfigurerAdapter,想要扩展的配置,只需要重写特定的方法即可</p></li><li><p>MVC的自动配置类也是继承了改类实现的</p></li><li><p><strong>注意:::::spring5中,因为jdk8中defulat的出现,使得接口中也可以写方法的实现,所以WebMvcConfigurerAdapter过时,我们自定义想要的MVC组件,可以直接实现接口WebMvcConfigurer,选择想要的组件即可</strong></p></li><li><p>在spring中,配置组件会看容器中,是否有用户自己配置的组件,若有则用用户的,无,则自动配置</p><ol><li>spring会从环境中加载所有相关配置,并进行判断   <h4 id="完全掌控SpringMVC"><a href="#完全掌控SpringMVC" class="headerlink" title="完全掌控SpringMVC"></a>完全掌控SpringMVC</h4></li></ol></li><li><p>类上加@EnableWebMvc</p></li><li><p>原理:</p>      <h4 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h4></li><li><p>编写国际化配置文件</p></li><li><p>使用ResourceBundleMessageSource管理国际化资源文件</p></li><li><p>在页面使用fmt:message取出国际化内容<br>步骤:</p></li><li><p>编写国际化配置文件,抽取页面需要显示的国际化消息</p>  <ol><li>需要去页面配置页面路径  </li><li>默认是从类路径下寻找名叫message的配置文件</li><li>但是我们定义了在classpath/i18n/</li><li>如图,需要在spring主配置文件中写入:::spring.messages.basename=i18n.login<h4 id="获取国际化的值"><a href="#获取国际化的值" class="headerlink" title="获取国际化的值"></a>获取国际化的值</h4></li></ol></li><li><p>#{}</p></li><li><p>无文本内容使用行内表达式[[#{}]]</p><h4 id="Locale-LocaleResolver"><a href="#Locale-LocaleResolver" class="headerlink" title="Locale,LocaleResolver"></a>Locale,LocaleResolver</h4></li><li><p>从请求头中获取区域信息</p><h4 id="项目完善"><a href="#项目完善" class="headerlink" title="项目完善"></a>项目完善</h4> </li><li><p>还需要加入到容器中</p><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><h5 id="静态资源映射"><a href="#静态资源映射" class="headerlink" title="静态资源映射"></a>静态资源映射</h5></li><li><p>springboot已完成配置</p><h5 id="模板引擎缓存"><a href="#模板引擎缓存" class="headerlink" title="模板引擎缓存"></a>模板引擎缓存</h5><h5 id="表单重复提交-重定向"><a href="#表单重复提交-重定向" class="headerlink" title="表单重复提交(重定向)"></a>表单重复提交(重定向)</h5><h5 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h5></li><li><p>实现HandlerInterceptor接口</p></li><li><p>检查session中是否有该用户</p></li><li><p>有则放行</p></li><li><p>无则跳转登录界面(转发)</p></li><li><p>在主配置类中重写自定义的拦截器</p>  <h5 id="自定义日期格式化器"><a href="#自定义日期格式化器" class="headerlink" title="自定义日期格式化器"></a>自定义日期格式化器</h5></li><li><p>在spring主配置文件写spring.mvc.data-format=yyyy-MM-dd</p><h3 id="Restful"><a href="#Restful" class="headerlink" title="Restful"></a>Restful</h3></li><li><p>用HTTP请求的方式区别对资源的CRUD操作</p>    <h3 id="thymeleaf抽取公共页面元素"><a href="#thymeleaf抽取公共页面元素" class="headerlink" title="thymeleaf抽取公共页面元素"></a>thymeleaf抽取公共页面元素</h3> <h4 id="获取路径变量"><a href="#获取路径变量" class="headerlink" title="获取路径变量"></a>获取路径变量</h4><p>@PathVariable</p><h4 id="put提交"><a href="#put提交" class="headerlink" title="put提交"></a>put提交</h4>  <h3 id="错误处理机制"><a href="#错误处理机制" class="headerlink" title="错误处理机制"></a>错误处理机制</h3></li><li><p>原理:ErroMvcAutoConfiguration</p><h4 id="定制错误响应"><a href="#定制错误响应" class="headerlink" title="定制错误响应:"></a>定制错误响应:</h4><h5 id="定制错误页面"><a href="#定制错误页面" class="headerlink" title="定制错误页面:"></a>定制错误页面:</h5><h6 id="有模板引擎"><a href="#有模板引擎" class="headerlink" title="有模板引擎"></a>有模板引擎</h6></li><li><p>有模板引擎:error/状态码[将错误页面命名为,错误状态码.html放在模板引擎文件夹下的error文件夹下],发生此状态码的错误就会来到对应的页面</p></li><li><p>我们可以使用4XX和5XX作为错误页面的文件名来匹配这种类型的所有错误,精确优先(优先寻找精确的状态码)</p></li><li><p>页面能获取的信息</p><ol><li>timestamp:时间戳</li><li>status:状态码</li><li>error:错误提示</li><li>exception:异常对象</li><li>message:错误信息</li><li>errors:JSR303数据校验<h6 id="无模板引擎"><a href="#无模板引擎" class="headerlink" title="无模板引擎"></a>无模板引擎</h6></li></ol></li><li><p>静态资源文件夹下找</p></li></ol><h5 id="定制错误消息"><a href="#定制错误消息" class="headerlink" title="定制错误消息"></a>定制错误消息</h5><h3 id="嵌入式Servlet容器"><a href="#嵌入式Servlet容器" class="headerlink" title="嵌入式Servlet容器"></a>嵌入式Servlet容器</h3><ol><li>springboot默认使用嵌入式的Servlet容器<h4 id="定制和修改Servlet相关配置"><a href="#定制和修改Servlet相关配置" class="headerlink" title="定制和修改Servlet相关配置"></a>定制和修改Servlet相关配置</h4></li><li>主配置文件中修改和server有关的配置(serverProperties)<br>server.Tomcat<h5 id="springboot2-0"><a href="#springboot2-0" class="headerlink" title="springboot2.0"></a>springboot2.0</h5></li><li>编写一个(根据各种容器)WebServerFactoryCustomizer(接口):嵌入式的servlet容器定制器<ol><li>TomcatWebServerFactoryCustomizer</li><li>JettyWebServerFactoryCustomizer<br>#####springboot</li></ol></li><li>编写一个EmbeddedServletContainerCustomizer嵌入式的servlet容器定制器<h4 id="注册servlet三大组件-servlt-filter-listener"><a href="#注册servlet三大组件-servlt-filter-listener" class="headerlink" title="注册servlet三大组件(servlt,filter,listener)"></a>注册servlet三大组件(servlt,filter,listener)</h4></li><li>servletRegistrationBean</li><li>FilterRegistrationBean</li><li>ServletListenerRegistrationBean</li></ol><h4 id="其他的Servlet容器"><a href="#其他的Servlet容器" class="headerlink" title="其他的Servlet容器"></a>其他的Servlet容器</h4><ol><li>在自定义servlet容器时,可以tomcat.jetty,Undertow都可以配置(参数是父接口,三个自定义配置类的父接口)</li><li>POM选择排除tmocat,导入选择的嵌入式容器<h5 id="Jetty-长链接-会话-聊天"><a href="#Jetty-长链接-会话-聊天" class="headerlink" title="Jetty(长链接(会话,聊天))"></a>Jetty(长链接(会话,聊天))</h5><h5 id="Undertow-不支持jsp-并发性能好"><a href="#Undertow-不支持jsp-并发性能好" class="headerlink" title="Undertow(不支持jsp,并发性能好)"></a>Undertow(不支持jsp,并发性能好)</h5><h5 id="嵌入式servlet容器自动配置的原理"><a href="#嵌入式servlet容器自动配置的原理" class="headerlink" title="嵌入式servlet容器自动配置的原理"></a>嵌入式servlet容器自动配置的原理</h5></li><li>判断属于哪种嵌入式servlet容器 </li><li>通过WebServerFactoryCustomizerBeanPostProcessor在WebServerFactoryCustomizer初始化之前,获取所有的自定义器,然后配置 </li><li>然后通过WebServerFactoryCustomizer.customize()方法,依次配置<h5 id="嵌入式的servlet容器启动原理"><a href="#嵌入式的servlet容器启动原理" class="headerlink" title="嵌入式的servlet容器启动原理"></a>嵌入式的servlet容器启动原理</h5></li><li>未完待续!!!!!!!!还没理解<h5 id="使用外置的servlet容器"><a href="#使用外置的servlet容器" class="headerlink" title="使用外置的servlet容器"></a>使用外置的servlet容器</h5></li><li>嵌入式:jar<ol><li>优点:简单编写</li><li>缺点:默认不支持jsp,优化定制比较复杂,(使用定制器,webserverFactoryCustomizer)</li></ol></li><li>使用外置的<ol><li>打包方式改为war包</li><li>创建外置的目录结构src/main/webapp/WEB-INF/web.xml</li><li>部署在tomcat服务器里(与idea集成(pom文件scope改为provided))</li><li>必须编写一个SpringBootServletInitializer的子类,并调用configure方法 <h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5></li></ol></li><li>jar:执行main方法,启动ioc容器,再创建嵌入式servlet容器</li><li>war:启动服务器,服务器启动springboot应用,再启动ioc容器</li><li>具体的没了解透,待更新<h3 id="springboot-数据访问"><a href="#springboot-数据访问" class="headerlink" title="springboot 数据访问"></a>springboot 数据访问</h3></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="codeStudy" scheme="http://yoursite.com/categories/codeStudy/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="hide" scheme="http://yoursite.com/tags/hide/"/>
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Git&amp;&amp;Github</title>
    <link href="http://yoursite.com/2020/04/19/Git-Github/"/>
    <id>http://yoursite.com/2020/04/19/Git-Github/</id>
    <published>2020-04-19T05:04:20.000Z</published>
    <updated>2020-05-17T14:43:11.281Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Git-分布式版本控制系统"><a href="#Git-分布式版本控制系统" class="headerlink" title="Git(分布式版本控制系统)"></a>Git(分布式版本控制系统)</h3><h4 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h4><ol><li>各个开发人员,并发进行模块编写,会产生不同的版本,然后汇总,手工合并代码,工程量巨大,git可以解决..git也完美的解决了合并冲突的问题</li><li>集中式版本控制系统存在单点故障:<ol><li>当服务器出现故障,历史版本及文件信息全部消失,只有客户端中存在当前版本的信息,且各个客户端版本不同,无法找回历史,且合并也存在问题</li></ol></li></ol><h5 id="协同修改"><a href="#协同修改" class="headerlink" title="协同修改"></a>协同修改</h5><ol><li>多人并行不悖的修改服务器的同一个文件</li></ol><h5 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h5><ol><li>不仅保存目录和文件的当前状态,还保存每一个提交的历史状态</li></ol><h5 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h5><ol><li>保存文件信息,避免重复数据</li></ol><h5 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h5><ol><li>对团队参与开发的人员进行权限控制</li><li>团队外进行代码审核<ol><li><strong>fork到本用户的远程仓库–&gt;clone克隆到本地–&gt;mod对文件或者代码进行修改–&gt;push推送到远程仓库–&gt;pull request(发送拉取请求,仓库所有者进行审核,审核通过,则代码合并)</strong></li></ol></li></ol><h5 id="历史记录"><a href="#历史记录" class="headerlink" title="历史记录"></a>历史记录</h5><ol><li>查看修改人、修改时间、日志信息</li><li>将本地文件恢复到某个历史状态</li></ol><h5 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h5><ol><li>允许发开团队在工作过程中同时推进任务</li></ol><h4 id="Git的结构"><a href="#Git的结构" class="headerlink" title="Git的结构"></a>Git的结构</h4><h5 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h5><ol><li>写代码</li></ol><h5 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a>暂存区</h5><ol><li>临时存储,可以commit到本地库,也可以git restore –staged hello.txt返回到工作区</li></ol><h5 id="本地库"><a href="#本地库" class="headerlink" title="本地库"></a>本地库</h5><ol><li>存放历史版本的文件</li></ol><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><h5 id="本地库操作"><a href="#本地库操作" class="headerlink" title="本地库操作"></a>本地库操作</h5><h6 id="git-init-本地库初始化"><a href="#git-init-本地库初始化" class="headerlink" title="git init(本地库初始化)"></a>git init(本地库初始化)</h6><ol><li>会生成一个.git目录和文件,存放本地库相关的内容</li></ol><h6 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h6><ol start="0"><li>区别不同开发的人员</li><li>git config &lt;user.name&gt;/&lt;user.email&gt;(设置项目级别,仅在本地库范围内有效)</li><li>git config –global &lt;user.name&gt;/&lt;user.email&gt;(设置系统用户级别,在当前windows用户下有效)</li></ol><h6 id="git-status-状态查看操作"><a href="#git-status-状态查看操作" class="headerlink" title="git status( 状态查看操作)"></a>git status( 状态查看操作)</h6><h6 id="git-add-filename-添加到暂存区"><a href="#git-add-filename-添加到暂存区" class="headerlink" title="git add [filename] (添加到暂存区)"></a>git add [filename] (添加到暂存区)</h6><h6 id="git-commit-m-“message”-filename"><a href="#git-commit-m-“message”-filename" class="headerlink" title="git commit -m “message” [filename]"></a>git commit -m “message” [filename]</h6><h6 id="git-log-查看历史版本-不好用"><a href="#git-log-查看历史版本-不好用" class="headerlink" title="git log(查看历史版本 不好用)"></a>git log(查看历史版本 不好用)</h6><p>####### git log –pretty=online (每条记录显示一行)<br>####### git log online (只显示部分哈希值,每条记录显示一行)<br>####### git reflog (只显示部分哈希值,且有HEAD指针的情况,每条记录显示一行)</p><h6 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h6><p>####### git reset –hard [历史版本哈希索引值] (前往历史版本)</p><ol><li>本地库移动HEAD指针</li><li>重置暂存区</li><li>重置工作区<br>####### git reset –mixed [历史版本哈希索引值] (前往历史版本)</li><li>本地库移动HEAD指针</li><li>重置暂存区<br>####### git reset –soft  [历史版本哈希索引值] (前往历史版本)仅在本地库移动HEAD指针</li><li>也可以跟^(有几个异或符号就代表退后几步)</li><li>也可以跟~n(写几就回退几步)</li><li>这两只能后退,不能前进</li></ol><h6 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h6><ol><li>无参表示在工作区时,文件更改的差异,,,,,红色代表删除,绿色代表新增(更改)<br>####### git [filename] HEAD(可以是本地库的历史版本) apple.txt</li><li>和本地库中的文件进行比较</li><li>不指定文件名会比较所有文件</li></ol><h6 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h6><p>####### git branch -v(查看所有分支)<br>####### git branch [branchName] (创建新分支)<br>####### git checkout [branchName] (切换分支)<br>####### 合并分支</p><ol><li>必须先切换到需要接受修改的分支 git checkout [name]</li><li>执行merge [有新内容的分支名]<br>######## 合并冲突</li><li>当前分支和另一分支都对同一个内容进行了更改</li><li>解决<ol><li>编辑文件</li><li>更改到满意的程度,保存退出</li><li>git add [filename]</li><li>git commit -m “message” 不加文件名</li></ol></li></ol><h6 id="遇到问题-删除文件找回"><a href="#遇到问题-删除文件找回" class="headerlink" title="遇到问题(删除文件找回)"></a>遇到问题(删除文件找回)</h6><ol><li>删除已提交到本地库</li><li>回退到未删除的版本</li><li>删除操作存在到暂存区</li><li>回退到当前版本</li></ol><h5 id="远程库操作"><a href="#远程库操作" class="headerlink" title="远程库操作"></a>远程库操作</h5><h6 id="给远程库起别名"><a href="#给远程库起别名" class="headerlink" title="给远程库起别名"></a>给远程库起别名</h6><ol><li>git remote add origin(别名) 远程库地址</li><li>git remote -v 查看别名</li></ol><h6 id="git-push-origin-远程库别名-master-分支"><a href="#git-push-origin-远程库别名-master-分支" class="headerlink" title="git push origin(远程库别名) master(分支)"></a>git push origin(远程库别名) master(分支)</h6><h5 id="克隆远程库"><a href="#克隆远程库" class="headerlink" title="克隆远程库"></a>克隆远程库</h5><ol><li>git clone 克隆地址</li><li>克隆完成,初始化自动完成,别名也附带</li></ol><h5 id="拉取操作-保持版本一致"><a href="#拉取操作-保持版本一致" class="headerlink" title="拉取操作(保持版本一致)"></a>拉取操作(保持版本一致)</h5><ol><li>git pull [远程地址别名]  [远程分支别名] </li><li>git pull = git fetch [远程地址别名]  [远程分支别名] +git merge(拿到文件+合并)</li></ol><h5 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h5><ol><li>若本地的文件和不是基于远程库的最新版进行的修改,则无法进行push</li><li>需要先pull下来,再进行修改</li></ol><h5 id="跨团队协作"><a href="#跨团队协作" class="headerlink" title="跨团队协作"></a>跨团队协作</h5><ol><li>fork 到个人的远程库</li><li>clone到个人本地库</li><li>进行修改</li><li>push到个人的远程库</li><li>pull request 到对方的远程库</li><li>审核完成</li><li>合并分支即可</li></ol><h3 id="Github-代码托管中心"><a href="#Github-代码托管中心" class="headerlink" title="Github(代码托管中心)"></a>Github(代码托管中心)</h3><h4 id="代码托管中心"><a href="#代码托管中心" class="headerlink" title="代码托管中心"></a>代码托管中心</h4><h4 id="SSH免密登录"><a href="#SSH免密登录" class="headerlink" title="SSH免密登录"></a>SSH免密登录</h4><ol><li>ssh-keygen -t rsa -C <a href="mailto:812227969@qq.com">812227969@qq.com</a></li><li>cat id_rsa.pub<br>复制前往github  settings</li><li>OOK<img src="/2020/04/19/Git-Github/OK.png" class><h5 id="github"><a href="#github" class="headerlink" title="github"></a>github</h5></li></ol><h5 id="gitlab"><a href="#gitlab" class="headerlink" title="gitlab"></a>gitlab</h5><h5 id="码云"><a href="#码云" class="headerlink" title="码云"></a>码云</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="codeStudy" scheme="http://yoursite.com/categories/codeStudy/"/>
    
    
      <category term="hide" scheme="http://yoursite.com/tags/hide/"/>
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
</feed>
